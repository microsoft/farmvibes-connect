diff --git a/.vscode/settings.json b/.vscode/settings.json
index 7e655c06..c88714be 100644
--- a/.vscode/settings.json
+++ b/.vscode/settings.json
@@ -1,5 +1,10 @@
 // Place your settings in this file to overwrite default and user settings.
 {
+ 
+    "cortex-debug.gdbPath": "/path/to/arm-none-eabi-gdb",
+    "cortex-debug.stlinkPath": "/path/to/ST-LINK Utility",
+    "cortex-debug.openocdPath": "/path/to/openocd",
+
     "cmake.configureSettings": {
 
         // In case your GNU ARM-Toolchain is not installed under the default
@@ -10,7 +15,7 @@
         //     Linux   : /usr
         //     OSX     : /usr/local
         // It is required to uncomment and to fill the following line.
-        //"TOOLCHAIN_PREFIX":"/path/to/toolchain",
+        "TOOLCHAIN_PREFIX":"/path/to/GNU ARM toolchain",
 
         // In case your OpenOCD is not installed under the default path:
         //     Windows : C:/openocd/bin/openocd.exe
@@ -33,7 +38,7 @@
         // Select the default LoRaWAN class for periodic-uplink-lpp sub-project
         // In case `CLASS_B` or `CLASS_C` is selected the example will try to
         // switch to the given class as soon as possible
-        "LORAWAN_DEFAULT_CLASS":"CLASS_A",
+        "LORAWAN_DEFAULT_CLASS":"CLASS_B",
 
         // Switch for Class B support of LoRaMac:
         "CLASSB_ENABLED":"ON",
@@ -41,7 +46,7 @@
         // Select the active region for which the stack will be initialized.
         // You can choose between:
         // LORAMAC_REGION_EU868, LORAMAC_REGION_US915, ..
-        "ACTIVE_REGION":"LORAMAC_REGION_EU868",
+        "ACTIVE_REGION":"LORAMAC_REGION_US470",
 
         // Select the type of modulation, applicable to the ping-pong or
         // rx-sensi applications. You can choose between:
@@ -50,7 +55,7 @@
 
         // Target board, the following boards are supported:
         // NAMote72, NucleoL073 (Default), NucleoL152, NucleoL476, SAMR34, SKiM880B, SKiM980A, SKiM881AXL, B-L072Z-LRWAN1.
-        "BOARD":"NucleoL073",
+        "BOARD":"NucleoL152",
 
         // MBED Radio shield selection. (Applies only to Nucleo platforms)
         // The following shields are supported:
@@ -66,7 +71,8 @@
 
         // Region support activation, Select the ones you want to support.
         // By default only REGION_EU868 support is enabled.
-        "REGION_EU868":"ON",
+        "REGION_US470":"ON",
+        "REGION_EU868":"OFF",
         "REGION_US915":"OFF",
         "REGION_CN779":"OFF",
         "REGION_EU433":"OFF",
@@ -76,6 +82,7 @@
         "REGION_KR920":"OFF",
         "REGION_IN865":"OFF",
         "REGION_RU864":"OFF",
+        
 
         // Default channel plan for region AS923. Possible selections:
         // CHANNEL_PLAN_GROUP_AS923_1, CHANNEL_PLAN_GROUP_AS923_2, CHANNEL_PLAN_GROUP_AS923_3,
@@ -85,5 +92,33 @@
         // Default channel plan for region CN470. Possible selections:
         // CHANNEL_PLAN_20MHZ_TYPE_A, CHANNEL_PLAN_20MHZ_TYPE_B, CHANNEL_PLAN_26MHZ_TYPE_A, CHANNEL_PLAN_26MHZ_TYPE_B
         "REGION_CN470_DEFAULT_CHANNEL_PLAN":"CHANNEL_PLAN_20MHZ_TYPE_A"
+    },
+    "files.associations": {
+        "MLTable": "yaml",
+        "loramac.h": "c",
+        "regionnvm.h": "c",
+        "regioncn470.h": "c",
+        "regionus470.h": "c",
+        "gpio.h": "c",
+        "board.h": "c",
+        "tvws-board.h": "c",
+        "commissioning.h": "c",
+        "nvmdatamgmt.h": "c",
+        "scd30.h": "c",
+        "gpio-board.h": "c",
+        "rtc-board.h": "c",
+        "stm32l1xx.h": "c",
+        "utilities.h": "c",
+        "lpm-board.h": "c",
+        "board-config.h": "c",
+        "systime.h": "c",
+        "limits": "c",
+        "tvws_at.h": "c",
+        "lmhandler.h": "c",
+        "cli.h": "c",
+        "loramactypes.h": "c",
+        "se-identity.h": "c",
+        "stdlib.h": "c"
+    },
+    "C_Cpp.errorSquiggles": "disabled"
     }
-}
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index b9289eaa..d1ffd4d2 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -88,6 +88,7 @@ elseif(BOARD STREQUAL NucleoL073)
     endif()
 
 elseif(BOARD STREQUAL NucleoL152)
+    
     # Configure toolchain for NucleoL152
     set(LINKER_SCRIPT ${CMAKE_CURRENT_SOURCE_DIR}/boards/NucleoL152/cmsis/arm-gcc/stm32l152xe_flash.ld)
     include(stm32l1)
diff --git a/src/apps/LoRaMac/CMakeLists.txt b/src/apps/LoRaMac/CMakeLists.txt
index 814e307e..a25a2574 100644
--- a/src/apps/LoRaMac/CMakeLists.txt
+++ b/src/apps/LoRaMac/CMakeLists.txt
@@ -21,7 +21,7 @@ cmake_minimum_required(VERSION 3.6)
 #---------------------------------------------------------------------------------------
 # Options
 #---------------------------------------------------------------------------------------
-
+set(COMMON_INC_DIR  "${CMAKE_CURRENT_LIST_DIR}/common")
 # Allow switching of sub projects
 set(SUB_PROJECT_LIST periodic-uplink-lpp fuota-test-01)
 set(SUB_PROJECT periodic-uplink-lpp CACHE STRING "Default sub project is periodic-uplink-lpp")
@@ -37,9 +37,9 @@ endif()
 # Allow switching of active region
 set(ACTIVE_REGION_LIST   LORAMAC_REGION_EU868 LORAMAC_REGION_US915 LORAMAC_REGION_CN779
     LORAMAC_REGION_EU433 LORAMAC_REGION_AU915 LORAMAC_REGION_AS923 LORAMAC_REGION_CN470
-    LORAMAC_REGION_KR920 LORAMAC_REGION_IN865 LORAMAC_REGION_RU864
+    LORAMAC_REGION_KR920 LORAMAC_REGION_IN865 LORAMAC_REGION_RU864 LORAMAC_REGION_US470
 )
-set(ACTIVE_REGION LORAMAC_REGION_EU868 CACHE STRING "Default active region is EU868")
+set(ACTIVE_REGION LORAMAC_REGION_US470 CACHE STRING "Default active region is US470")
 set_property(CACHE ACTIVE_REGION PROPERTY STRINGS ${ACTIVE_REGION_LIST})
 
 if((SUB_PROJECT STREQUAL periodic-uplink-lpp OR SUB_PROJECT STREQUAL fuota-test-01) AND NOT CLASSB_ENABLED )
diff --git a/src/apps/LoRaMac/common/CayenneLpp.c b/src/apps/LoRaMac/common/CayenneLpp.c
index a2e33cf8..0f8702e1 100644
--- a/src/apps/LoRaMac/common/CayenneLpp.c
+++ b/src/apps/LoRaMac/common/CayenneLpp.c
@@ -255,3 +255,32 @@ uint8_t CayenneLppAddGps( uint8_t channel, float latitude, float longitude, floa
 
     return CayenneLppCursor;
 }
+uint8_t CayenneLppAddGenericSensor( uint8_t channel, float sensor_val )
+{
+    if( ( CayenneLppCursor + LPP_GENERIC_SENSOR_SIZE ) > CAYENNE_LPP_MAXBUFFER_SIZE )
+    {
+        return 0;
+    }
+    int16_t val = ( int16_t ) ( sensor_val * 10 );
+
+    CayenneLppBuffer[CayenneLppCursor++] = channel; 
+    CayenneLppBuffer[CayenneLppCursor++] = LPP_GENERIC_SENSOR; 
+    CayenneLppBuffer[CayenneLppCursor++] = val >> 8; 
+    CayenneLppBuffer[CayenneLppCursor++] = val; 
+
+    return CayenneLppCursor;
+}
+
+ uint8_t CayenneLppAddGenericADCSensor( uint8_t channel, uint16_t adc )
+{
+    if( ( CayenneLppCursor + LPP_GENERIC_ADC_SENSOR_SIZE ) > CAYENNE_LPP_MAXBUFFER_SIZE )
+    {
+        return 0;
+    }
+    CayenneLppBuffer[CayenneLppCursor++] = channel; 
+    CayenneLppBuffer[CayenneLppCursor++] = LPP_GENERIC_ADC_SENSOR; 
+    CayenneLppBuffer[CayenneLppCursor++] = adc >> 8; 
+    CayenneLppBuffer[CayenneLppCursor++] = adc; 
+
+    return CayenneLppCursor;
+}
diff --git a/src/apps/LoRaMac/common/CayenneLpp.h b/src/apps/LoRaMac/common/CayenneLpp.h
index 01cec2e9..dae6daeb 100644
--- a/src/apps/LoRaMac/common/CayenneLpp.h
+++ b/src/apps/LoRaMac/common/CayenneLpp.h
@@ -39,8 +39,8 @@ extern "C" {
 #define LPP_BAROMETRIC_PRESSURE 115     // 2 bytes 0.1 hPa Unsigned
 #define LPP_GYROMETER           134     // 2 bytes per axis, 0.01 ┬░/s
 #define LPP_GPS                 136     // 3 byte lon/lat 0.0001 ┬░, 3 bytes alt 0.01m
-
-
+#define LPP_GENERIC_SENSOR      146 // 2 bytes
+#define LPP_GENERIC_ADC_SENSOR  156 // 2 bytes
 // Data ID + Data Type + Data Size
 #define LPP_DIGITAL_INPUT_SIZE       3
 #define LPP_DIGITAL_OUTPUT_SIZE      3
@@ -54,7 +54,8 @@ extern "C" {
 #define LPP_BAROMETRIC_PRESSURE_SIZE 4
 #define LPP_GYROMETER_SIZE           8
 #define LPP_GPS_SIZE                 11
-
+#define LPP_GENERIC_SENSOR_SIZE      4
+#define LPP_GENERIC_ADC_SENSOR_SIZE   2
 void CayenneLppInit( void );
 
 void CayenneLppReset( void );
@@ -76,7 +77,8 @@ uint8_t CayenneLppAddAccelerometer( uint8_t channel, float x, float y, float z )
 uint8_t CayenneLppAddBarometricPressure( uint8_t channel, float hpa );
 uint8_t CayenneLppAddGyrometer( uint8_t channel, float x, float y, float z );
 uint8_t CayenneLppAddGps( uint8_t channel, float latitude, float longitude, float meters );
-
+uint8_t CayenneLppAddGenericSensor( uint8_t channel, float sensor_val );
+uint8_t CayenneLppAddGenericADCSensor( uint8_t channel, uint16_t adc );
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/apps/LoRaMac/common/Commissioning.h b/src/apps/LoRaMac/common/Commissioning.h
index bb5ce36b..50a7d0a8 100644
--- a/src/apps/LoRaMac/common/Commissioning.h
+++ b/src/apps/LoRaMac/common/Commissioning.h
@@ -44,16 +44,17 @@ extern "C" {
  * When set to 1 the application uses the Over-the-Air activation procedure
  * When set to 0 the application uses the Personalization activation procedure
  */
-#define OVER_THE_AIR_ACTIVATION                            1
+#define OVER_THE_AIR_ACTIVATION                          1
 
 /*!
  * When using ABP activation the MAC layer must know in advance to which server
  * version it will be connected.
  */
-#define ABP_ACTIVATION_LRWAN_VERSION_V10x                  0x01000400 // 1.0.4.0
+
+#define ABP_ACTIVATION_LRWAN_VERSION_V10x                  0x01000300 // 1.0.3.0
 #define ABP_ACTIVATION_LRWAN_VERSION_V11x                  0x01010100 // 1.1.1.0
 
-#define ABP_ACTIVATION_LRWAN_VERSION                       ABP_ACTIVATION_LRWAN_VERSION_V11x
+#define ABP_ACTIVATION_LRWAN_VERSION                       ABP_ACTIVATION_LRWAN_VERSION_V10x
 
 /*!
  * Indicates if the end-device is to be connected to a private or public network
diff --git a/src/apps/LoRaMac/common/LmHandler/LmHandler.c b/src/apps/LoRaMac/common/LmHandler/LmHandler.c
index 3ebdcd54..890e0585 100644
--- a/src/apps/LoRaMac/common/LmHandler/LmHandler.c
+++ b/src/apps/LoRaMac/common/LmHandler/LmHandler.c
@@ -249,7 +249,7 @@ LmHandlerErrorStatus_t LmHandlerInit( LmHandlerCallbacks_t *handlerCallbacks,
     }
 
     // Restore data if required
-    nbNvmData = NvmDataMgmtRestore( );
+     nbNvmData = NvmDataMgmtRestore( );
 
     // Try to restore from NVM and query the mac if possible.
     if( nbNvmData > 0 )
@@ -389,7 +389,8 @@ void LmHandlerProcess( void )
             .Port = 0,
         };
 
-        if( LmHandlerSend( &appData, LmHandlerParams->IsTxConfirmed ) == LORAMAC_HANDLER_SUCCESS )
+   // if( LmHandlerSend( &appData, LmHandlerParams->IsTxConfirmed ) == LORAMAC_HANDLER_SUCCESS )
+   if( LmHandlerSend( &appData,LORAMAC_HANDLER_CONFIRMED_MSG) == LORAMAC_HANDLER_SUCCESS )
         {
             IsUplinkTxPending = false;
         }
@@ -477,6 +478,24 @@ LmHandlerErrorStatus_t LmHandlerSend( LmHandlerAppData_t *appData, LmHandlerMsgT
 
     TxParams.MsgType = isTxConfirmed;
     mcpsReq.Type = ( isTxConfirmed == LORAMAC_HANDLER_UNCONFIRMED_MSG ) ? MCPS_UNCONFIRMED : MCPS_CONFIRMED;
+    #ifdef REGION_US470 
+        
+        if( appData->BufferSize >  11)
+        {
+             LmHandlerParams->TxDatarate=1;
+        }else if( appData->BufferSize >  53)
+        {
+            LmHandlerParams->TxDatarate=2;
+        }
+        else if( appData->BufferSize >  125)
+        {
+            LmHandlerParams->TxDatarate=3;
+        }
+        else
+        {
+             LmHandlerParams->TxDatarate=0;
+        }
+    #endif
     mcpsReq.Req.Unconfirmed.Datarate = LmHandlerParams->TxDatarate;
     if( LoRaMacQueryTxPossible( appData->BufferSize, &txInfo ) != LORAMAC_STATUS_OK )
     {
@@ -568,12 +587,14 @@ LmHandlerErrorStatus_t LmHandlerPingSlotReq( uint8_t periodicity )
     if( status == LORAMAC_STATUS_OK )
     {
         // Send an empty message
+        
         LmHandlerAppData_t appData =
         {
             .Buffer = NULL,
             .BufferSize = 0,
             .Port = 0,
         };
+       
         return LmHandlerSend( &appData, LmHandlerParams->IsTxConfirmed );
     }
     else
@@ -805,7 +826,9 @@ static void MlmeConfirm( MlmeConfirm_t *mlmeConfirm )
             {
                 // Beacon has been acquired
                 // Request server for ping slot
-                LmHandlerPingSlotReq( LmHandlerParams->PingSlotPeriodicity );
+                #ifndef REGION_US470
+                       LmHandlerPingSlotReq( LmHandlerParams->PingSlotPeriodicity );
+                #endif
             }
             else
             {
@@ -879,7 +902,7 @@ static void MlmeIndication( MlmeIndication_t *mlmeIndication )
         {
             BeaconParams.State = LORAMAC_HANDLER_BEACON_RX;
             BeaconParams.Info = mlmeIndication->BeaconInfo;
-
+           // printf("Beacon Locked\r\n");
             LmHandlerCallbacks->OnBeaconStatusChange( &BeaconParams );
         }
         else
@@ -1030,3 +1053,213 @@ static void LmHandlerPackagesProcess( void )
         }
     }
 }
+#ifdef REGION_US470
+ 
+void UTIL_MEM_cpy_8( void *dst, const void *src, uint16_t size )
+{
+  uint8_t* dst8= (uint8_t *) dst;
+  uint8_t* src8= (uint8_t *) src;
+
+  while( size-- )
+    {
+        *dst8++ = *src8++;
+    }
+}
+
+int32_t LmHandlerGetDevEUI(uint8_t *devEUI)
+{
+  if (devEUI == NULL)
+  {
+    return LORAMAC_HANDLER_ERROR;
+  }
+    MibRequestConfirm_t mibReq;
+    mibReq.Type = MIB_DEV_EUI;
+    if (LoRaMacMibGetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
+    {
+      return LORAMAC_HANDLER_ERROR;
+    }
+       UTIL_MEM_cpy_8( devEUI,  mibReq.Param.DevEui, SE_EUI_SIZE);
+   UTIL_MEM_cpy_8(CommissioningParams.DevEui, devEUI, SE_EUI_SIZE);
+  return LORAMAC_HANDLER_SUCCESS;
+
+
+
+}
+int32_t LmHandlerSetDevEUI(uint8_t *devEUI)
+{
+ 
+  MibRequestConfirm_t mibReq;
+
+  /* Not yet joined */
+  if (LmHandlerJoinStatus() != LORAMAC_HANDLER_SET)
+  {
+    mibReq.Type = MIB_DEV_EUI;
+    mibReq.Param.DevEui =devEUI;
+    if (LoRaMacMibSetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
+    {
+      return LORAMAC_HANDLER_ERROR;
+    }
+    UTIL_MEM_cpy_8(CommissioningParams.DevEui, devEUI, SE_EUI_SIZE);
+    return LORAMAC_HANDLER_SUCCESS;
+  }
+  else
+  {
+    /* Cannot change Keys in running state */
+    return LORAMAC_HANDLER_ERROR;
+  }
+ 
+}
+
+LmHandlerErrorStatus_t LmHandlerGetAppEUI(uint8_t *appEUI)
+{
+    MibRequestConfirm_t mibReq;
+
+    if (appEUI == NULL)
+    {
+        return LORAMAC_HANDLER_ERROR;
+    }
+
+    mibReq.Type = MIB_JOIN_EUI;
+    if (LoRaMacMibGetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
+    {
+        return LORAMAC_HANDLER_ERROR;
+    }
+    UTIL_MEM_cpy_8(appEUI, mibReq.Param.JoinEui, SE_EUI_SIZE);
+    return LORAMAC_HANDLER_SUCCESS;
+}
+
+LmHandlerErrorStatus_t LmHandlerSetAppEUI(uint8_t *appEUI)
+{
+    MibRequestConfirm_t mibReq;
+
+    /* Not yet joined */
+    if (LmHandlerJoinStatus() != LORAMAC_HANDLER_SET)
+    {
+        mibReq.Type = MIB_JOIN_EUI;
+        mibReq.Param.JoinEui = appEUI;
+        if (LoRaMacMibSetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
+        {
+            return LORAMAC_HANDLER_ERROR;
+        }
+         UTIL_MEM_cpy_8(CommissioningParams.JoinEui, appEUI, SE_EUI_SIZE);
+        return LORAMAC_HANDLER_SUCCESS;
+    }
+    else
+    {
+        /* Cannot change Keys in running state */
+        return LORAMAC_HANDLER_ERROR;
+    }
+}
+
+LmHandlerErrorStatus_t LmHandlerGetNwkKey( uint8_t *nwkKey )
+{
+ 
+    Key_t *keyItem;
+ 
+
+    if (nwkKey == NULL)
+    {
+        return LORAMAC_HANDLER_ERROR;
+    }
+ 
+    if (0 != SecureElementGetKeyByID(NWK_KEY, &keyItem))
+    {
+        return LORAMAC_HANDLER_ERROR;
+    }
+    UTIL_MEM_cpy_8( nwkKey, keyItem->KeyValue, 16 );
+ 
+    return LORAMAC_HANDLER_SUCCESS;
+}
+
+LmHandlerErrorStatus_t LmHandlerSetNwkKey( uint8_t *nwkKey )
+{
+    /* Not yet joined */
+    if( LmHandlerJoinStatus( ) != LORAMAC_HANDLER_SET )
+    {
+        MibRequestConfirm_t mibReq;
+        mibReq.Type = MIB_NWK_KEY;
+        mibReq.Param.NwkKey = nwkKey;
+        if (LoRaMacMibSetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
+        {
+            return LORAMAC_HANDLER_ERROR;
+        }
+        return LORAMAC_HANDLER_SUCCESS;
+    }
+    else
+    {
+        /* Cannot change Keys in running state */
+        return LORAMAC_HANDLER_ERROR;
+    }
+}
+
+LmHandlerErrorStatus_t LmHandlerGetAppKey( uint8_t *appKey )
+{
+#if (!defined (LORAWAN_KMS) || (LORAWAN_KMS == 0))
+    Key_t *keyItem;
+#endif
+
+    if (appKey == NULL)
+    {
+        return LORAMAC_HANDLER_ERROR;
+    }
+
+    if (0 != SecureElementGetKeyByID(APP_KEY, &keyItem))
+    {
+        return LORAMAC_HANDLER_ERROR;
+    }
+    UTIL_MEM_cpy_8( appKey, keyItem->KeyValue, 16 );
+
+    return LORAMAC_HANDLER_SUCCESS;
+}
+
+LmHandlerErrorStatus_t LmHandlerSetAppKey( uint8_t *appKey )
+{
+    /* Not yet joined */
+    if( LmHandlerJoinStatus( ) != LORAMAC_HANDLER_SET )
+    {
+        MibRequestConfirm_t mibReq;
+        mibReq.Type = MIB_APP_KEY;
+        mibReq.Param.AppKey = appKey;
+        if (LoRaMacMibSetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
+        {
+            return LORAMAC_HANDLER_ERROR;
+        }
+        return LORAMAC_HANDLER_SUCCESS;
+    }
+    else
+    {
+        /* Cannot change Keys in running state */
+        return LORAMAC_HANDLER_ERROR;
+    }
+}
+LmHandlerErrorStatus_t LmHandlerSetTxPower(int8_t txPower)
+{
+    MibRequestConfirm_t mibReq;
+
+    mibReq.Type = MIB_CHANNELS_TX_POWER;
+    mibReq.Param.ChannelsTxPower = txPower;
+    if (LoRaMacMibSetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
+    {
+        return LORAMAC_HANDLER_ERROR;
+    }
+
+    return LORAMAC_HANDLER_SUCCESS;
+}
+LmHandlerErrorStatus_t LmHandlerGetTxPower(int8_t *txPower)
+{
+    MibRequestConfirm_t mibReq;
+    if (txPower == NULL)
+    {
+        return LORAMAC_HANDLER_ERROR;
+    }
+
+    mibReq.Type = MIB_CHANNELS_TX_POWER;
+    if (LoRaMacMibGetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
+    {
+        return LORAMAC_HANDLER_ERROR;
+    }
+
+    *txPower = mibReq.Param.ChannelsTxPower;
+    return LORAMAC_HANDLER_SUCCESS;
+}
+#endif
\ No newline at end of file
diff --git a/src/apps/LoRaMac/common/LmHandlerMsgDisplay.c b/src/apps/LoRaMac/common/LmHandlerMsgDisplay.c
index 637a7e10..7aad885b 100644
--- a/src/apps/LoRaMac/common/LmHandlerMsgDisplay.c
+++ b/src/apps/LoRaMac/common/LmHandlerMsgDisplay.c
@@ -112,16 +112,17 @@ void PrintHexBuffer( uint8_t *buffer, uint8_t size )
 
 void DisplayNvmDataChange( LmHandlerNvmContextStates_t state, uint16_t size )
 {
+
     if( state == LORAMAC_HANDLER_NVM_STORE )
     {
-        printf( "\n###### ============ CTXS STORED ============ ######\n" );
+        printf( "\n# = CTXS STORED ##\r\n" );
 
     }
     else
     {
-        printf( "\n###### =========== CTXS RESTORED =========== ######\n" );
+        printf( "\n#  CTXS RESTORED \r\n" );
     }
-    printf( "Size        : %i\n\n", size );
+    printf( "Size        : %i\r\n", size );
 }
 
 void DisplayNetworkParametersUpdate( CommissioningParams_t *commissioningParams )
@@ -148,38 +149,39 @@ void DisplayNetworkParametersUpdate( CommissioningParams_t *commissioningParams
 
 void DisplayMacMcpsRequestUpdate( LoRaMacStatus_t status, McpsReq_t *mcpsReq, TimerTime_t nextTxIn )
 {
+    return;
     switch( mcpsReq->Type )
     {
         case MCPS_CONFIRMED:
         {
-            printf( "\n###### =========== MCPS-Request ============ ######\n" );
-            printf( "######            MCPS_CONFIRMED             ######\n");
-            printf( "###### ===================================== ######\n");
+        //    printf( "\n#  MCPS-Request ##\n" );
+            printf( "M CNF #\r\n");
+      //      printf( "# #\n");
             break;
         }
         case MCPS_UNCONFIRMED:
         {
-            printf( "\n###### =========== MCPS-Request ============ ######\n" );
-            printf( "######           MCPS_UNCONFIRMED            ######\n");
-            printf( "###### ===================================== ######\n");
+      //      printf( "\n#  MCPS-Request ##\n" );
+            printf( "M UCNF\n");
+   //         printf( "# #\n");
             break;
         }
         case MCPS_PROPRIETARY:
         {
-            printf( "\n###### =========== MCPS-Request ============ ######\n" );
-            printf( "######           MCPS_PROPRIETARY            ######\n");
-            printf( "###### ===================================== ######\n");
+      //      printf( "\n#  MCPS-Request ##\n" );
+            printf( "M PROP\n");
+      //      printf( "# #\n");
             break;
         }
         default:
         {
-            printf( "\n###### =========== MCPS-Request ============ ######\n" );
-            printf( "######                MCPS_ERROR             ######\n");
-            printf( "###### ===================================== ######\n");
+          //  printf( "\n#  MCPS-Request ##\n" );
+       //     printf( "#    MCPS_ERROR  #\r\n");
+       //     printf( "# #\n");
             break;
         }
     }
-    printf( "STATUS      : %s\n", MacStatusStrings[status] );
+ //   printf( "STATUS      : %s\n", MacStatusStrings[status] );
     if( status == LORAMAC_STATUS_DUTYCYCLE_RESTRICTED )
     {
         printf( "Next Tx in  : %lu [ms]\n", nextTxIn );
@@ -188,45 +190,84 @@ void DisplayMacMcpsRequestUpdate( LoRaMacStatus_t status, McpsReq_t *mcpsReq, Ti
 
 void DisplayMacMlmeRequestUpdate( LoRaMacStatus_t status, MlmeReq_t *mlmeReq, TimerTime_t nextTxIn )
 {
+    return;
     switch( mlmeReq->Type )
     {
         case MLME_JOIN:
         {
-            printf( "\n###### =========== MLME-Request ============ ######\n" );
-            printf( "######               MLME_JOIN               ######\n");
-            printf( "###### ===================================== ######\n");
+            printf("\tMLME-JN\r\n");
+            /*
+            printf( "\n#  MLME-Request ##\n" );
+            printf( "#   MLME_JOIN    #\n");
+            printf( "# #\n");
+            */
             break;
         }
         case MLME_LINK_CHECK:
         {
-            printf( "\n###### =========== MLME-Request ============ ######\n" );
-            printf( "######            MLME_LINK_CHECK            ######\n");
-            printf( "###### ===================================== ######\n");
+         //   printf( "\n#  MLME-Request ##\n" );
+            printf( "#MLME_LINK_CHECK #\r\n");
+        //    printf( "# #\n");
             break;
         }
         case MLME_DEVICE_TIME:
         {
-            printf( "\n###### =========== MLME-Request ============ ######\n" );
-            printf( "######            MLME_DEVICE_TIME           ######\n");
-            printf( "###### ===================================== ######\n");
+        //    printf( "\n#  MLME-Request ##\n" );
+            printf( "#MLME_DEVICE_TIME#\n");
+       //     printf( "# #\n");
             break;
         }
         case MLME_TXCW:
         {
-            printf( "\n###### =========== MLME-Request ============ ######\n" );
-            printf( "######               MLME_TXCW               ######\n");
-            printf( "###### ===================================== ######\n");
+          //  printf( "\n#  MLME-Request ##\n" );
+            printf( "#   MLME_TXCW    #\n");
+         //   printf( "# #\n");
+            break;
+        }
+          case MLME_BEACON:
+        {
+        //    printf( "\n#  MLME-Request ##\n" );
+            printf( "#   MLME_BEACON    #\n");
+       //     printf( "# #\n");
+            break;
+        }
+          case MLME_BEACON_ACQUISITION:
+        {
+      //      printf( "\n#  MLME-Request ##\n" );
+            printf( "#   MLME_BEACON_ACQUISITION   ######\n");
+      //      printf( "# #\n");
+            break;
+        }
+             case MLME_PING_SLOT_INFO:
+        {
+         //   printf( "\n#  MLME-Request ##\n" );
+            printf( "#   MLME_PING_SLOT_INFO    #\n");
+         //   printf( "# #\n");
+            break;
+        }
+        case MLME_BEACON_TIMING:
+        {
+          //  printf( "\n#  MLME-Request ##\n" );
+            printf( "#   MLME_BEACON_TIMING    #\n");
+          //  printf( "# #\n");
+            break;
+        }
+             case MLME_BEACON_LOST:
+        {
+       //     printf( "\n#  MLME-Request ##\n" );
+            printf( "#   MLME_BEACON_LOST    #\n");
+       //     printf( "# #\n");
             break;
         }
         default:
         {
-            printf( "\n###### =========== MLME-Request ============ ######\n" );
-            printf( "######              MLME_UNKNOWN             ######\n");
-            printf( "###### ===================================== ######\n");
+         //   printf( "\n#  MLME-Request ##\n" );
+            printf( "#  MLME_UNKNOWN  #\n");
+         //   printf( "# #\n");
             break;
         }
     }
-    printf( "STATUS      : %s\n", MacStatusStrings[status] );
+   // printf( "\tSTATUS   : %s\n", MacStatusStrings[status] );
     if( status == LORAMAC_STATUS_DUTYCYCLE_RESTRICTED )
     {
         printf( "Next Tx in  : %lu [ms]\n", nextTxIn );
@@ -239,39 +280,50 @@ void DisplayJoinRequestUpdate( LmHandlerJoinParams_t *params )
     {
         if( params->Status == LORAMAC_HANDLER_SUCCESS )
         {
-            printf( "###### ===========   JOINED     ============ ######\n" );
+            printf( "#    JOINED     ##\n" );
             printf( "\nOTAA\n\n" );
             printf( "DevAddr     :  %08lX\n", params->CommissioningParams->DevAddr );
             printf( "\n\n" );
             printf( "DATA RATE   : DR_%d\n\n", params->Datarate );
+            #ifdef REGION_US470
+                extern uint8_t tvws_joined;
+                tvws_joined=1;
+            #endif
+
         }
     }
 #if ( OVER_THE_AIR_ACTIVATION == 0 )
     else
     {
-        printf( "###### ===========   JOINED     ============ ######\n" );
+        printf( "#    JOINED     ##\n" );
         printf( "\nABP\n\n" );
         printf( "DevAddr     : %08lX\n", params->CommissioningParams->DevAddr );
         printf( "\n\n" );
+        #ifdef REGION_US470
+            extern uint8_t tvws_joined;
+            tvws_joined=1;
+         #endif
     }
 #endif
 }
 
 void DisplayTxUpdate( LmHandlerTxParams_t *params )
 {
+    return ;
     MibRequestConfirm_t mibGet;
 
     if( params->IsMcpsConfirm == 0 )
     {
-        printf( "\n###### =========== MLME-Confirm ============ ######\n" );
-        printf( "STATUS      : %s\n", EventInfoStatusStrings[params->Status] );
+       // printf( "\n#  MLME-Confirm ##\n" );
+      //  printf( "STATUS      : %s\n", EventInfoStatusStrings[params->Status] );
+        printf( "\tMLEC-ST: %s\n", EventInfoStatusStrings[params->Status] );
         return;
     }
 
-    printf( "\n###### =========== MCPS-Confirm ============ ######\n" );
+    printf( "\n#  MCPS-Confirm ##\n" );
     printf( "STATUS      : %s\n", EventInfoStatusStrings[params->Status] );
 
-    printf( "\n###### =====   UPLINK FRAME %8lu   ===== ######\n", params->UplinkCounter );
+    printf( "\n# UPLINK FRAME %8lu ##\n", params->UplinkCounter );
     printf( "\n" );
 
     printf( "CLASS       : %c\n", "ABC"[LmHandlerGetCurrentClass( )] );
@@ -292,8 +344,8 @@ void DisplayTxUpdate( LmHandlerTxParams_t *params )
         PrintHexBuffer( params->AppData.Buffer, params->AppData.BufferSize );
     }
 
-    printf( "\n" );
-    printf( "DATA RATE   : DR_%d\n", params->Datarate );
+  //  printf( "\n" );
+    printf( "DATA RATE : DR_%d\n", params->Datarate );
 
     mibGet.Type  = MIB_CHANNELS;
     if( LoRaMacMibGetRequestConfirm( &mibGet ) == LORAMAC_STATUS_OK )
@@ -323,6 +375,7 @@ void DisplayTxUpdate( LmHandlerTxParams_t *params )
             case LORAMAC_REGION_AU915:
             case LORAMAC_REGION_CN470:
             case LORAMAC_REGION_US915:
+           
             {
                 for( uint8_t i = 0; i < 5; i++)
                 {
@@ -330,9 +383,17 @@ void DisplayTxUpdate( LmHandlerTxParams_t *params )
                 }
                 break;
             }
+            case LORAMAC_REGION_US470:
+            {
+                for( uint8_t i = 0; i < 3 ; i++)
+                {
+                    printf( "%04X ", mibGet.Param.ChannelsMask[i] );
+                }
+                break;
+            }
             default:
             {
-                printf( "\n###### ========= Unknown Region ============ ######" );
+                printf( "\n###### ========= Unknown Region ##" );
                 break;
             }
         }
@@ -348,15 +409,15 @@ void DisplayRxUpdate( LmHandlerAppData_t *appData, LmHandlerRxParams_t *params )
 
     if( params->IsMcpsIndication == 0 )
     {
-        printf( "\n###### ========== MLME-Indication ========== ######\n" );
+        printf( "\n## MLME-Indication ========== ######\n" );
         printf( "STATUS      : %s\n", EventInfoStatusStrings[params->Status] );
         return;
     }
 
-    printf( "\n###### ========== MCPS-Indication ========== ######\n" );
+    printf( "\n## MCPS-Indication ========== ######\n" );
     printf( "STATUS      : %s\n", EventInfoStatusStrings[params->Status] );
 
-    printf( "\n###### =====  DOWNLINK FRAME %8lu  ===== ######\n", params->DownlinkCounter );
+    printf( "\n###### =====  DOWNLINK FRAME %8lu##\n", params->DownlinkCounter );
 
     printf( "RX WINDOW   : %s\n", slotStrings[params->RxSlot] );
     
@@ -388,7 +449,7 @@ void DisplayBeaconUpdate( LoRaMacHandlerBeaconParams_t *params )
         }
         case LORAMAC_HANDLER_BEACON_LOST:
         {
-            printf( "\n###### ============ BEACON LOST ============ ######\n" );
+            printf( "\n# = BEACON LOST ##\n" );
             break;
         }
         case LORAMAC_HANDLER_BEACON_RX:
@@ -403,6 +464,10 @@ void DisplayBeaconUpdate( LoRaMacHandlerBeaconParams_t *params )
             printf( "RX RSSI     : %d\n", params->Info.Rssi );
             printf( "RX SNR      : %d\n", params->Info.Snr );
             printf( "\n" );
+            #ifdef REGION_US470
+                extern uint8_t tvws_start_uplink;
+                tvws_start_uplink =1;
+            #endif
             break;
         }
         case LORAMAC_HANDLER_BEACON_NRX:
@@ -415,14 +480,14 @@ void DisplayBeaconUpdate( LoRaMacHandlerBeaconParams_t *params )
 
 void DisplayClassUpdate( DeviceClass_t deviceClass )
 {
-    printf( "\n\n###### ===== Switch to Class %c done.  ===== ######\n\n", "ABC"[deviceClass] );
+    printf( "\n\n###### ===== Switch to Class %c done.##\n\n", "ABC"[deviceClass] );
 }
 
 void DisplayAppInfo( const char* appName, const Version_t* appVersion, const Version_t* gitHubVersion )
 {
-    printf( "\n###### ===================================== ######\n\n" );
+    printf( "\n# #\n\n" );
     printf( "Application name   : %s\n", appName );
     printf( "Application version: %d.%d.%d\n", appVersion->Fields.Major, appVersion->Fields.Minor, appVersion->Fields.Patch );
     printf( "GitHub base version: %d.%d.%d\n", gitHubVersion->Fields.Major, gitHubVersion->Fields.Minor, gitHubVersion->Fields.Patch );
-    printf( "\n###### ===================================== ######\n\n" );
+    printf( "\n# #\n\n" );
 }
diff --git a/src/apps/LoRaMac/common/NvmDataMgmt.c b/src/apps/LoRaMac/common/NvmDataMgmt.c
index f9e820d1..b7d07f74 100644
--- a/src/apps/LoRaMac/common/NvmDataMgmt.c
+++ b/src/apps/LoRaMac/common/NvmDataMgmt.c
@@ -42,7 +42,7 @@
  * Must be enabled for LoRaWAN 1.0.4 or later.
  */
 #ifndef CONTEXT_MANAGEMENT_ENABLED
-#define CONTEXT_MANAGEMENT_ENABLED         1
+#define CONTEXT_MANAGEMENT_ENABLED       0
 #endif
 
 
@@ -217,8 +217,9 @@ uint16_t NvmDataMgmtRestore( void )
 
 bool NvmDataMgmtFactoryReset( void )
 {
-    uint16_t offset = 0;
+
 #if( CONTEXT_MANAGEMENT_ENABLED == 1 )
+    uint16_t offset = 0;
     // Crypto
     if( NvmmReset( sizeof( LoRaMacCryptoNvmData_t ), offset ) == false )
     {
@@ -270,3 +271,4 @@ bool NvmDataMgmtFactoryReset( void )
 #endif
     return true;
 }
+ 
\ No newline at end of file
diff --git a/src/apps/LoRaMac/common/tvws-board.c b/src/apps/LoRaMac/common/tvws-board.c
new file mode 100644
index 00000000..06048134
--- /dev/null
+++ b/src/apps/LoRaMac/common/tvws-board.c
@@ -0,0 +1,736 @@
+#include "tvws-board.h"
+#include "gpio.h"
+#include "sx126x.h"
+#include "stm32l1xx_hal.h"
+#include "adc.h"
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include "i2c-board.h"
+#include "NvmDataMgmt.h"
+#define ADCCLK_ENABLE()                 __HAL_RCC_ADC1_CLK_ENABLE() ;
+#define ADCCLK_DISABLE()                 __HAL_RCC_ADC1_CLK_DISABLE() ;
+
+#define MAX_NMEA_SENTENCE 256
+#define MAX_NMEA_FIELDS 20
+
+ 
+#include "rtc-board.h"
+#define GPS_EPOCH 315964800  // GPS epoch starts at 1980-01-06 00:00:00
+ 
+
+
+extern ADC_HandleTypeDef AdcHandle;
+extern Adc_t Adc;
+
+#define ADC_VREF_BANDGAP                            1224 // mV
+/* Internal voltage reference, parameter VREFINT_CAL*/
+#define VREFINT_CAL       ((uint16_t*) ((uint32_t) 0x1FF800F8))
+
+
+static uint8_t sync_mcu_rtc_with_gps_time=1;
+/* Internal temperature sensor: constants data used for indicative values in  */
+/* this example. Refer to device datasheet for min/typ/max values.            */
+
+/* Internal temperature sensor, parameter TS_CAL1: TS ADC raw data acquired at
+ *a temperature of 110 DegC (+-5 DegC), VDDA = 3.3 V (+-10 mV). */
+#define TEMP30_CAL_ADDR   ((uint16_t*) ((uint32_t) 0x1FF800FA))
+
+/* Internal temperature sensor, parameter TS_CAL2: TS ADC raw data acquired at
+ *a temperature of  30 DegC (+-5 DegC), VDDA = 3.3 V (+-10 mV). */
+#define TEMP110_CAL_ADDR  ((uint16_t*) ((uint32_t) 0x1FF800FE))
+
+/* Vdda value with which temperature sensor has been calibrated in production
+   (+-10 mV). */
+#define VDDA_TEMP_CAL                  ((uint32_t) 3000)
+
+
+#define COMPUTE_TEMPERATURE(TS_ADC_DATA, VDDA_APPLI)                           \
+  ((((( ((int32_t)((TS_ADC_DATA * VDDA_APPLI) / VDDA_TEMP_CAL)                  \
+        - (int32_t) *TEMP30_CAL_ADDR)                                          \
+     ) * (int32_t)(110 - 30)                                                   \
+    )<<8) / (int32_t)(*TEMP110_CAL_ADDR - *TEMP30_CAL_ADDR)                        \
+   ) + (30<<8)                                                                      \
+  )
+
+
+
+
+#define Board_rfSwitch_0  PA15Pin
+#define Board_rfSwitch_1 PB6Pin
+#define Board_rfSwitch_2 PB5Pin
+#define Board_rfSwitch_3 PB15Pin
+#define Board_rfSwitch_4 PB0Pin
+#define Board_rfSwitch_5 PC7Pin
+#define Board_rfSwitch_6 PC8Pin
+#define Board_rfSwitch_7 PC9Pin
+#define Board_rfSwitch_LNA PC6Pin
+#define Board_rfSwitch_VDD PB10Pin
+
+#define GPS_PWR_SWITCH PB2Pin
+#define Board_CNm6_VDD PB12Pin
+#define Board_TXCO PD2Pin
+
+#define SENSOR_A_POWER PC3Pin
+#define SENSOR_B_POWER PC2Pin
+ 
+
+Gpio_t Board_rfSwitch_0;
+Gpio_t Board_rfSwitch_1;
+Gpio_t Board_rfSwitch_2;
+Gpio_t Board_rfSwitch_3;
+Gpio_t Board_rfSwitch_4;
+Gpio_t Board_rfSwitch_5;
+Gpio_t Board_rfSwitch_6;
+Gpio_t Board_rfSwitch_7;
+Gpio_t Board_rfSwitch_VDD;
+Gpio_t Board_rfSwitch_LNA;
+Gpio_t GPS_PWR_SWITCH;
+
+Gpio_t Board_TXCO ;
+Gpio_t Board_CNm6_VDD;
+
+Gpio_t SENSOR_A_POWER;
+Gpio_t SENSOR_B_POWER;
+Gpio_t PA1Pin;
+Gpio_t PA4Pin; 
+Adc_t ADC_A  ;
+Adc_t ADC_B ;   
+static int  TVWS_GPIOInitialized =0;
+extern Gpio_t DeviceSel;
+TVWS_RF_CHANNELS current_rftx_band=CHANNEL_UHF3_GT_458MHz_667MHz;
+TVWS_RF_CHANNELS current_rfrx_band=CHANNEL_VLAN_160MHz_960MHz;
+TVWS_RF_CHANNELS current_state=CHANNEL_UHF3_GT_458MHz_667MHz;
+uint8_t tvws_gnss_enabled=1;
+static uint8_t last_hour=0;
+#define TIMEZONE_OFFSET 0
+extern void GetRTCDateTime(struct tm *time_struct);
+
+#define SECONDS_IN_HOUR 3600
+
+RTC_DateTypeDef wsdb_date;
+RTC_TimeTypeDef wsdb_time ;
+uint8_t tvws_wsdb_registered=0;
+struct tm timeinfo;
+volatile uint64_t diff=0;
+
+ time_t last_epoch_time=0;
+ time_t current_epoch_time=0;
+ 
+uint8_t CheckWSDBExpiry(time_t epochTime)
+{
+  if(  tvws_wsdb_registered)
+  {
+ 
+
+  struct tm time_struct;
+  time_t unix_time;
+  
+  GetRTCDateTime(&time_struct);
+  time_struct.tm_mon = time_struct.tm_mon -1;
+  time_struct.tm_year=time_struct.tm_year +100;
+  unix_time = mktime(&time_struct);
+  unix_time = unix_time - epochTime;
+  if (unix_time > (SECONDS_IN_HOUR*24) )
+    {
+      TVWSInitGnss();
+      TVWSGetGPS(); // reacquire GPS
+      tvws_wsdb_registered=0;
+    }
+  }
+
+  return !(tvws_wsdb_registered);
+}
+
+int SetGPSState(uint8_t state)
+{
+     GpioWrite( &PB2Pin, state );
+     return state;
+}
+int SetTVWSDebugState(uint8_t state)
+{
+     
+return 0;
+}
+int SetTVWSGPSState(uint8_t state)
+{
+  
+  sync_mcu_rtc_with_gps_time=state;
+  GpioWrite( &GPS_PWR_SWITCH, state );
+  return state;
+
+}
+void SetTVWSBoardPower(uint8_t state)
+{
+  GpioWrite( &Board_TXCO, state);
+  GpioWrite( &Board_CNm6_VDD, state );
+  HAL_Delay(100);
+}
+int SetTVWSBand(TVWS_RF_CHANNELS band)
+{
+    int retval=0;
+    if(!TVWS_GPIOInitialized)
+    {
+        TVWSInitGPIO();
+    }
+    current_state=band;
+    if(band !=ALL_OFF)
+    {
+        GpioWrite( &Board_rfSwitch_VDD, 1 );
+    }
+ 
+ 
+switch(band)
+{
+    case ALL_OFF:
+        GpioWrite( &Board_rfSwitch_0, 0 );
+        GpioWrite( &Board_rfSwitch_1, 0 );
+        GpioWrite( &Board_rfSwitch_2, 0 );
+        GpioWrite( &Board_rfSwitch_3, 0 );
+        GpioWrite( &Board_rfSwitch_4, 0 );
+        GpioWrite( &Board_rfSwitch_5, 0 );
+        GpioWrite( &Board_rfSwitch_6, 0 );
+        GpioWrite( &Board_rfSwitch_7, 0 );
+    break;
+
+    case CHANNEL_VHF_150MHz_217MHz:
+         GpioWrite( &Board_rfSwitch_0, 0 );
+        GpioWrite( &Board_rfSwitch_1, 1 );
+        GpioWrite( &Board_rfSwitch_2, 1 );
+        GpioWrite( &Board_rfSwitch_3, 1 );
+        GpioWrite( &Board_rfSwitch_4, 1 );
+        GpioWrite( &Board_rfSwitch_5, 1 );
+        GpioWrite( &Board_rfSwitch_6, 1);
+        GpioWrite( &Board_rfSwitch_7, 0 );
+   //     GpioWrite( &Board_rfSwitch_VDD, 1 );
+       
+    // GPIO
+    break;
+    case CHANNEL_UHF1_GT_217MHz_315MHz:
+        GpioWrite( &Board_rfSwitch_0, 0 );
+        GpioWrite( &Board_rfSwitch_1, 0 );
+        GpioWrite( &Board_rfSwitch_2, 1 );
+        GpioWrite( &Board_rfSwitch_3, 1 );
+        GpioWrite( &Board_rfSwitch_4, 1 );
+        GpioWrite( &Board_rfSwitch_5, 1 );
+        GpioWrite( &Board_rfSwitch_6, 0 );
+        GpioWrite( &Board_rfSwitch_7, 0 );
+        GpioWrite( &Board_rfSwitch_VDD, 1 );
+    break;
+    case CHANNEL_868_915_GT_667MHz_960MHz:
+        GpioWrite( &Board_rfSwitch_0, 0 );
+        GpioWrite( &Board_rfSwitch_1, 0 );
+        GpioWrite( &Board_rfSwitch_2, 0 );
+        GpioWrite( &Board_rfSwitch_3, 1 );
+        GpioWrite( &Board_rfSwitch_4, 1 );
+        GpioWrite( &Board_rfSwitch_5, 0 );
+        GpioWrite( &Board_rfSwitch_6, 1 );
+        GpioWrite( &Board_rfSwitch_7, 0 );
+  
+    break;
+    case CHANNEL_UHF2_GT_315MHz_458MHz:
+        GpioWrite( &Board_rfSwitch_0, 0);
+        GpioWrite( &Board_rfSwitch_1, 1 );
+        GpioWrite( &Board_rfSwitch_2, 0 );
+        GpioWrite( &Board_rfSwitch_3, 1 );
+        GpioWrite( &Board_rfSwitch_4, 1 );
+        GpioWrite( &Board_rfSwitch_5, 0 );
+        GpioWrite( &Board_rfSwitch_6, 0 );
+        GpioWrite( &Board_rfSwitch_7, 0 );
+    break;
+    case CHANNEL_UHF3_GT_458MHz_667MHz:
+    //U1 Control
+        GpioWrite( &Board_rfSwitch_0, 1 );
+        GpioWrite( &Board_rfSwitch_1, 0 );
+        GpioWrite( &Board_rfSwitch_2, 0 );
+        GpioWrite( &Board_rfSwitch_3, 1 );
+        GpioWrite( &Board_rfSwitch_4, 1 );
+        GpioWrite( &Board_rfSwitch_5, 0 );
+        GpioWrite( &Board_rfSwitch_6, 0 );
+        GpioWrite( &Board_rfSwitch_7, 1 );
+        GpioWrite( &Board_rfSwitch_VDD, 1 );
+    break;
+   case CHANNEL_VLAN_160MHz_960MHz:
+   case RF_STATE_RX_EN_LNA:
+        GpioWrite( &Board_rfSwitch_0, 1 );
+        GpioWrite( &Board_rfSwitch_1, 1 );
+        GpioWrite( & Board_rfSwitch_2, 1 );
+        GpioWrite( &Board_rfSwitch_3, 1 );
+        GpioWrite( &Board_rfSwitch_4, 0 );
+        GpioWrite( &Board_rfSwitch_5, 1 );
+        GpioWrite( &Board_rfSwitch_6, 0 );
+        GpioWrite( &Board_rfSwitch_7, 1 );
+        GpioWrite(&Board_rfSwitch_LNA, 1 );
+    break;   
+   break;
+   default:
+     retval=-1;
+}
+ 
+    return retval;
+
+}
+
+void TVWSInitGPIO()
+{
+
+if(! TVWS_GPIOInitialized)
+{
+    
+
+        GpioInit( &PA15Pin, PA_15, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 0 );
+        GpioInit( &PB6Pin, PB_6, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 0 );
+        GpioInit( &PB5Pin, PB_5, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 0 );
+        GpioInit( &PB15Pin, PB_15, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 0 );
+        GpioInit( &PB0Pin, PB_0, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 0 );
+        GpioInit( &PC7Pin, PC_7, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 0 );
+        GpioInit( &PC8Pin, PC_8, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 0 );
+        GpioInit( &PC9Pin, PC_9, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 0 );
+        GpioInit( &PB10Pin, PB_10, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 0 );
+        GpioInit( &PD2Pin, PD_2, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 0 );
+        GpioInit( &PB12Pin, PB_12, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 0 );
+        GpioInit( &PB2Pin, PB_2, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 0 );
+        GpioInit( &PC6Pin, PC_6, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 0 );
+
+        // Sensor Pin
+        GpioInit( &PC3Pin, PC_3, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 0 );
+        GpioInit( &PC2Pin, PC_2, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 0 );
+        GpioInit( &PA1Pin, PA_1, PIN_ANALOGIC, PIN_PUSH_PULL, PIN_NO_PULL, 0 );
+        
+        GpioInit( &PA4Pin, PA_4, PIN_ANALOGIC, PIN_PUSH_PULL, PIN_NO_PULL, 0 );
+        ADC_A.AdcInput=PA1Pin;
+        ADC_B.AdcInput=PA4Pin;
+        AdcInit(&ADC_A, PA_1);
+        AdcInit(&ADC_B, PA_4);
+
+     TVWS_GPIOInitialized=1; 
+}
+   
+
+}
+uint16_t TVWS_ReadADC(TVWS_ADC_SENSOR sensor)
+{
+  uint16_t retval=0;
+  switch (sensor)
+  {
+  case  TVWS_SENSOR_ADC_A:
+    GpioWrite( &SENSOR_A_POWER, 1 );
+     HAL_Delay(100);
+    retval =AdcReadChannel( &ADC_A,1 );
+       GpioWrite( &SENSOR_A_POWER, 0 );
+    break;
+   case  TVWS_SENSOR_ADC_B: 
+     GpioWrite( &SENSOR_B_POWER, 1 );
+     HAL_Delay(100);
+     retval =AdcReadChannel( &ADC_B,4 );
+    GpioWrite( &SENSOR_B_POWER, 0 );
+    break;
+  default:
+    break;
+  }
+  return retval;
+}
+uint16_t HW_AdcReadChannel(uint32_t Channel)
+{
+
+  ADC_ChannelConfTypeDef adcConf = {0};
+
+  uint16_t adcData = 0;
+/* wait the the Vrefint used by adc is set */
+    while (__HAL_PWR_GET_FLAG(PWR_FLAG_VREFINTRDY) == RESET) {};
+
+    ADCCLK_ENABLE();
+
+//    /* Deselects all channels*/
+//    adcConf.Channel = ADC_CHANNEL_MASK;
+//    adcConf.Rank = ADC_RANK_NONE;
+//    HAL_ADC_ConfigChannel( hadc, &adcConf);
+
+    /* configure adc channel */
+    adcConf.Channel = Channel;
+    adcConf.Rank = ADC_REGULAR_RANK_1;
+    adcConf.SamplingTime = ADC_SAMPLETIME_192CYCLES;
+    HAL_ADC_ConfigChannel(&AdcHandle, &adcConf);
+
+    /* Start the conversion process */
+    HAL_ADC_Start(&AdcHandle);
+
+    /* Wait for the end of conversion */
+    HAL_ADC_PollForConversion(&AdcHandle, HAL_MAX_DELAY);
+
+    /* Get the converted value of regular channel */
+    adcData = HAL_ADC_GetValue(&AdcHandle);
+
+    __HAL_ADC_DISABLE(&AdcHandle) ;
+
+    ADCCLK_DISABLE();
+  
+  return adcData;
+}
+int TWVS_DemoTemperatuerSensorConfig()
+{
+    int retval=0;
+     ADC_ChannelConfTypeDef sConfig = {0};
+    sConfig.Channel = ADC_CHANNEL_TEMPSENSOR;
+    sConfig.Rank = ADC_REGULAR_RANK_1;
+    sConfig.SamplingTime = ADC_SAMPLETIME_4CYCLES;
+  if (HAL_ADC_ConfigChannel(&AdcHandle, &sConfig) != HAL_OK)
+  {
+    retval=1;
+  }
+  return retval;
+}
+int TWVS_DemoTemperatureSensorRead()
+{
+uint16_t measuredLevel = 0;
+  uint32_t batteryLevelmV;
+  uint16_t temperatureDegreeC;
+uint16_t ref=(*VREFINT_CAL);
+  measuredLevel = HW_AdcReadChannel(ADC_CHANNEL_VREFINT);
+
+  if (measuredLevel == 0)
+  {
+    batteryLevelmV = 0;
+  }
+  else
+  {
+
+    batteryLevelmV = (((uint32_t) ADC_VREF_BANDGAP * ref) / measuredLevel);
+  }
+#if 0
+  PRINTF("VDDA= %d\n\r", batteryLevelmV);
+#endif
+
+  measuredLevel = HW_AdcReadChannel(ADC_CHANNEL_TEMPSENSOR);
+
+  temperatureDegreeC = COMPUTE_TEMPERATURE(measuredLevel, batteryLevelmV);
+
+#if 0
+  {
+    uint16_t temperatureDegreeC_Int = (temperatureDegreeC) >> 8;
+    uint16_t temperatureDegreeC_Frac = ((temperatureDegreeC - (temperatureDegreeC_Int << 8)) * 100) >> 8;
+    PRINTF("temp= %d, %d,%d\n\r", temperatureDegreeC, temperatureDegreeC_Int, temperatureDegreeC_Frac);
+  }
+#endif
+
+  return (uint16_t) temperatureDegreeC/1000;
+}
+extern SX126x_t SX126x;
+void TVWSSX126xIoInit( void )
+{
+    GpioInit( &SX126x.Spi.Nss, TVWS_RADIO_NSS, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 1 );
+    GpioInit( &SX126x.BUSY, TVWS_RADIO_BUSY, PIN_INPUT, PIN_PUSH_PULL, PIN_NO_PULL, 0 );
+    GpioInit( &SX126x.DIO1, TVWS_RADIO_DIO1, PIN_INPUT, PIN_PUSH_PULL, PIN_NO_PULL, 0 );
+    GpioInit( &DeviceSel, TVWS_RADIO_COSC, PIN_INPUT, PIN_PUSH_PULL, PIN_NO_PULL, 0 );
+}
+
+ 
+
+extern float lat,lon;
+  int TVWSGetChannelFromGns(char* sentence,uint16_t* tv_channel_index) {
+    char *tok;
+    int field_count = 0;
+    char utc_time[10];
+    char utc_date[10];
+    struct tm time_struct;
+    time_t unix_time;
+    double gps_time=0;
+    int retval=-1;
+    unsigned char tmp[2]={0};
+    tok = strtok(sentence, ",");
+    if ((strcmp(tok, "$GPRMC") == 0) || (strcmp(tok, "$GNRMC") == 0)) {
+    
+        field_count++;
+      uint8_t time_available =0;
+     while (tok != NULL && field_count < MAX_NMEA_FIELDS)
+     {
+
+         tok = strtok(NULL, ",");
+         field_count++;
+
+         uint8_t toklen=0;
+          if (tok != NULL)
+          { 
+           toklen= strlen(tok);
+          }
+            if (tok != NULL && *tok != ',' && toklen >0) {
+                switch (field_count) {
+                   case 2: //utc time
+                        strncpy(utc_time, tok, 9);
+                       
+                        break;
+                    case 3:
+                        if(strncmp(tok,"A",1)==0) // time ok
+                        {
+                            time_available++;
+                            printf("Valid Time\r\n");
+
+                        }
+                        break;
+                    case 4:
+                        lat=atof(tok);
+                       // sscanf(tok,"%f",&lat);
+                        break;
+                    case 5:
+                        if(strncmp(tok,"S",1)==0)
+                        {
+                            lat=-1*lat;
+
+                        }
+                        break;
+                    case 6:
+                       // sscanf(tok,"%f",&lon);
+                        lon=atof(tok);
+                        break;
+                    case 7:
+                        if(strncmp(tok,"W",1)==0)
+                        {
+                            lon=-1*lon;
+
+                        }
+                         
+                        break;
+                    case 9:
+                    case 10:
+                        //A = Autonomous, D = DGPS, E =DR
+                        if(tok[0] !='A' && tok[0]!='D' && tok[0]!='E'  && toklen >5) {
+                            strncpy(utc_date, tok, 7);
+                            time_available++;
+                        }
+                        break;
+                }
+            }
+        }
+
+    if(time_available>1)
+    {
+      
+        unsigned char *p=( unsigned char *)utc_time;
+        tmp[0]=*p++;
+        tmp[1]=*p++;;
+        time_struct.tm_hour=atoi( (const char *)tmp);
+        tmp[0]=*p++;
+        tmp[1]=*p++;
+        time_struct.tm_min=atoi((const char *)tmp);
+        tmp[0]=*p++;
+        tmp[1]=*p++;;
+        time_struct.tm_sec =atoi((const char *)tmp);
+        
+        p=( unsigned char *)utc_date;
+        tmp[0]=*p++;
+        tmp[1]=*p++;;
+        time_struct.tm_mday=atoi((const char *)tmp);
+        tmp[0]=*p++;
+        tmp[1]=*p++;;
+        time_struct.tm_mon=atoi((const char *)tmp) -1;
+        tmp[0]=*p++;
+        tmp[1]=*p++;;
+        time_struct.tm_year =2000 + atoi((const char *)tmp) -1900;
+
+
+        unix_time = mktime(&time_struct);
+        gps_time = difftime(unix_time, GPS_EPOCH);
+        
+       
+       
+        uint64_t nmb=(uint64_t)(gps_time / 128);
+        seconds_elasped =gps_time - nmb*128;
+        *tv_channel_index=(((uint64_t)nmb) % 22);
+         last_hour=time_struct.tm_hour;
+    
+        {
+         extern void SetRTCDateTime(uint8_t year, uint8_t month, uint8_t day, uint8_t hour, uint8_t minute, uint8_t second);
+         int8_t year = (uint8_t)time_struct.tm_year -100;
+         uint8_t month =(uint8_t)time_struct.tm_mon +1;
+         uint8_t day = (uint8_t)time_struct.tm_mday;
+         uint8_t hour =(uint8_t)time_struct.tm_hour;
+         uint8_t minute =(uint8_t)  time_struct.tm_min;
+         uint8_t second = (uint8_t)time_struct.tm_sec;
+         SetRTCDateTime(  year,   month,   day,   hour,   minute, second);
+
+        }
+        SetTVWSGPSState(0); //Power Off GPS
+        
+        retval=0;
+    }
+
+    }
+    return retval;
+}
+
+                
+
+ 
+#define UBLOX_I2C_ADDR 0x84
+const char  REGLEN    = 0xFD;
+const char REGSTREAM = 0xFF;
+
+
+#define GPS_REG_MEASUREMENT_RATE 0x09
+#define GPS_REG_PROTOCOL_OUTPUT 0x06
+#define GPS_REG_I2C_OUTPUT_PERIOD 0x0E
+#define GPS_REG_I2C_OUTPUT_DATA 0xFF
+
+int TVWSInitGnss()
+{
+uint8_t buf[4]={0};
+SetGPSState(1);
+HAL_Delay(100);
+buf[0]=GPS_REG_MEASUREMENT_RATE;
+buf[1]=0x03;
+buf[2]=0xE8;
+
+  int retval=I2cMcuWriteBuffer(&I2C_obj,UBLOX_I2C_ADDR,buf,3);
+
+  buf[0]=GPS_REG_PROTOCOL_OUTPUT;
+  buf[1]=0x07; //nmea
+   retval=I2cMcuWriteBuffer(&I2C_obj,UBLOX_I2C_ADDR,buf,2);
+ // Set the I2C output rate to match the measurement rate
+  buf[0]=GPS_REG_I2C_OUTPUT_PERIOD;
+  buf[1]=0x64 ; //100
+  retval=I2cMcuWriteBuffer(&I2C_obj,UBLOX_I2C_ADDR,buf,2);
+ 
+   return  retval;
+}
+
+
+int TVWSGetReadGnssMessage(char* buf, int len)
+{
+ uint8_t wbuf[4]={0};
+ wbuf[0]=GPS_REG_I2C_OUTPUT_DATA;
+ wbuf[1]=0 ; //100
+ int retval=I2cMcuWriteBuffer(&I2C_obj,UBLOX_I2C_ADDR,wbuf,1);
+  if(retval)
+  {
+   retval =  I2cMcuReadBuffer(&I2C_obj,UBLOX_I2C_ADDR | 1, (uint8_t*)buf,len);
+  }
+
+ 
+ return retval;
+  
+}
+
+
+
+int cntr=0;
+int TVWSProcessGPS()
+{
+  int retval=-1;
+char nmea_sentence[MAX_NMEA_SENTENCE]={0};
+volatile  int start_index=-1,end_index=-1;
+char sentence[100]={0};
+
+if((cntr++ % 500)==0)
+{
+ 
+  if(TVWSGetReadGnssMessage(nmea_sentence,MAX_NMEA_SENTENCE))
+  {
+    
+   
+     for(int i =0;i <MAX_NMEA_SENTENCE;i++)
+       {
+         if(nmea_sentence[i]=='$')
+         {
+          start_index=i;
+         }
+         if(start_index >=0 && nmea_sentence[i]=='\r')
+         {
+          end_index=i;
+          
+         }
+         if(end_index > start_index && nmea_sentence[i]=='\n')
+         {
+          int nlen=end_index-start_index;
+          for(int ncpi=0;ncpi <nlen;ncpi++)
+          {
+            sentence[ncpi]=nmea_sentence[ncpi+start_index];
+            printf("%c",sentence[ncpi]);
+         
+          }
+           printf("\r\n");
+           if(strstr((const char *) sentence,"GNRMC"))
+           {
+            retval= TVWSGetChannelFromGns(sentence,&beacon_channel_index);
+            if(retval < 0)
+            {
+              printf("Waiting on GPS Time\r\n");
+            }
+           }
+            start_index=-1;
+            end_index=-1;
+            memset1((uint8_t *)sentence,0,nlen);
+         }
+       
+       }
+  }
+}
+if(cntr>10000)
+{
+  cntr=0;
+}
+//HAL_Delay(50);
+return retval;
+}
+
+int TVWSProcessRTC(uint16_t* tv_channel_index)
+{
+  int retval=-1;
+ struct tm time_struct;
+  time_t unix_time;
+    double gps_time=0;
+        GetRTCDateTime(&time_struct);
+        time_struct.tm_mon = time_struct.tm_mon -1;
+        time_struct.tm_year=time_struct.tm_year +100;
+
+        unix_time = mktime(&time_struct);
+        gps_time = difftime(unix_time, GPS_EPOCH);
+        if(time_struct.tm_hour> last_hour)
+        {
+         
+          TVWSInitGnss();
+        }
+       
+      uint64_t nmb=(uint64_t)(gps_time / 128);
+      seconds_elasped =gps_time - nmb*128;
+      printf("RTC: %02d:%02d:%02d\r\n",time_struct.tm_hour,time_struct.tm_min,time_struct.tm_sec);
+      printf("RTC DATE: %02d:%02d:%04d\r\n",time_struct.tm_mday,time_struct.tm_mon+1,time_struct.tm_year+1900);
+      *tv_channel_index=(((uint64_t)nmb) % 22);
+      retval=0;
+
+return retval;
+}
+ int TVWSSyncMCURTC()
+ {
+  int retval=-1;
+  retval=TVWSProcessGPS();
+
+  return retval;
+ }
+int TVWComputeBeaconChannel()
+{
+ int retval=-1;
+   
+    retval=TVWSProcessRTC(&beacon_channel_index);
+   
+  return retval;
+}
+
+extern void BoardLowPowerHandler( void );
+void TVWSGetGPS()
+{
+  
+ // SetTVWSGPSState(1);
+  
+  while( TVWSSyncMCURTC()==-1 )
+  { 
+    BoardLowPowerHandler( );
+  }
+}
+
+uint8_t IsMCURTCInsync()
+{
+  
+return sync_mcu_rtc_with_gps_time;
+}
+
diff --git a/src/apps/LoRaMac/common/tvws-board.h b/src/apps/LoRaMac/common/tvws-board.h
new file mode 100644
index 00000000..f70a97aa
--- /dev/null
+++ b/src/apps/LoRaMac/common/tvws-board.h
@@ -0,0 +1,101 @@
+#ifndef __TVWS_BOARD_H__
+#define __TVWS_BOARD_H__
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+#include <stdint.h>
+#include <i2c.h>
+#include <time.h>
+typedef enum tag_TVWS_RF_CHANNELS
+{
+    CHANNEL_VHF_150MHz_217MHz,
+    CHANNEL_UHF1_GT_217MHz_315MHz,
+    CHANNEL_868_915_GT_667MHz_960MHz,
+    CHANNEL_UHF2_GT_315MHz_458MHz,
+    CHANNEL_UHF3_GT_458MHz_667MHz,
+    CHANNEL_VLAN_160MHz_960MHz,
+    RF_STATE_RX_EN_LNA,
+    ALL_OFF
+
+
+}TVWS_RF_CHANNELS;
+
+typedef enum tag_TVWS_I2C_STATUS
+{
+   
+        I2C_NO_ERROR,         //all ok
+        I2C_IS_READY,         //ready ststus register
+        I2C_NO_ACK_ERROR,   //no I2C ACK error
+        I2C_TIMEOUT_ERROR,    //I2C timeout error
+}TVWS_I2C_STATUS;
+
+typedef enum tag_SENSOR_ADC
+{
+    TVWS_SENSOR_ADC_A,
+    TVWS_SENSOR_ADC_B
+} TVWS_ADC_SENSOR;
+#define TVWS_RADIO_MOSI PA_7
+#define TVWS_RADIO_MISO PA_6
+#define TVWS_RADIO_SCLK PA_5
+#define TVWS_RADIO_NSS PA_8
+#define TVWS_RADIO_BUSY PB_3
+#define TVWS_RADIO_DIO1 PB_4
+#define TVWS_RADIO_DIO2 NC
+#define TVWS_RADIO_DIO3 NC
+#define TVWS_RADIO_NRESET PA_0
+#define TVWS_RADIO_COSC PD_2
+#define TVWS_RADIO_TXRX PB_12
+//#define GPS_PWR_SWITCH PB_2
+#define TVWS_DEBUG_PIN PB_8
+
+
+#define ADC_CHANNEL_TEMPSENSOR  ADC_CHANNEL_16  /* ADC internal channel (no connection on device pin). Channel common to both bank A and bank B. */
+#define ADC_CHANNEL_VREFINT     ADC_CHANNEL_17  /* ADC internal channel (no connection on device pin). Channel common to both bank A and bank B. */
+#define ADC_CHANNEL_VCOMP       ADC_CHANNEL_26 
+
+typedef enum tagEnum
+{
+    RF_CHAIN_A =0
+    ,RF_CHAIN_B=1
+
+}E_RF_CHAIN;
+int SetTVWSBand(TVWS_RF_CHANNELS band);
+void TVWSInitGPIO();
+void TVWSSX126xIoInit( void );
+int TWVS_DemoTemperatuerSensorConfig();
+int TWVS_DemoTemperatureSensorRead();
+int SetGPSState(uint8_t state);
+extern TVWS_RF_CHANNELS current_rftx_band;
+extern TVWS_RF_CHANNELS current_rfrx_band;
+extern TVWS_RF_CHANNELS current_state;
+int SetTVWSDebugState(uint8_t state);
+int SetTVWSGPSState(uint8_t state);
+void SetTVWSBoardPower(uint8_t state);
+int TVWSGetReadGnssMessage(char* buf, int len);
+int TVWSGetChannelFromGns(char* sentence,uint16_t* tv_channel_index) ;
+int TVWSInitGnss();
+void TVWSSetGnssState(uint8_t state);
+uint8_t IsTVWSGnssEnabled();
+
+extern uint16_t beacon_channel_index;
+ extern uint8_t switch_beacon_channel_enabled;
+extern uint8_t locked_tvws_beacon;
+
+extern I2c_t I2C_obj;
+extern uint8_t i2cBuff[34];
+extern uint64_t seconds_elasped;
+extern uint32_t beacon_frequencies[22];
+
+int TVWComputeBeaconChannel();
+int TVWSSyncMCURTC();
+uint8_t IsMCURTCInsync();
+ uint8_t TVWSDevEUISet();
+uint8_t CheckWSDBExpiry(time_t epochTime);
+void TVWSGetGPS();
+uint16_t TVWS_ReadADC(TVWS_ADC_SENSOR sensor);
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __BOARD_CONFIG_H__
diff --git a/src/apps/LoRaMac/fuota-test-01/NucleoL073/main.c b/src/apps/LoRaMac/fuota-test-01/NucleoL073/main.c
index 39ecae90..22aa2d09 100644
--- a/src/apps/LoRaMac/fuota-test-01/NucleoL073/main.c
+++ b/src/apps/LoRaMac/fuota-test-01/NucleoL073/main.c
@@ -332,7 +332,7 @@ int main( void )
     }
 
     // Set system maximum tolerated rx error in milliseconds
-    LmHandlerSetSystemMaxRxError( 20 );
+    LmHandlerSetSystemMaxRxError( 19 );
 
     // The LoRa-Alliance Compliance protocol package should always be
     // initialized and activated.
diff --git a/src/apps/LoRaMac/fuota-test-01/NucleoL152/main.c b/src/apps/LoRaMac/fuota-test-01/NucleoL152/main.c
index e239532e..e996a40b 100644
--- a/src/apps/LoRaMac/fuota-test-01/NucleoL152/main.c
+++ b/src/apps/LoRaMac/fuota-test-01/NucleoL152/main.c
@@ -68,8 +68,8 @@
  *
  * \remark Please note that when ADR is enabled the end-device should be static
  */
-#define LORAWAN_ADR_STATE                           LORAMAC_HANDLER_ADR_ON
-
+//#define LORAWAN_ADR_STATE                           LORAMAC_HANDLER_ADR_ON
+#define LORAWAN_ADR_STATE                           LORAMAC_HANDLER_ADR_OFF
 /*!
  * Default datarate
  *
diff --git a/src/apps/LoRaMac/periodic-uplink-lpp/NucleoL152/main.c b/src/apps/LoRaMac/periodic-uplink-lpp/NucleoL152/main.c
index fc29ec44..897e9d63 100644
--- a/src/apps/LoRaMac/periodic-uplink-lpp/NucleoL152/main.c
+++ b/src/apps/LoRaMac/periodic-uplink-lpp/NucleoL152/main.c
@@ -29,14 +29,20 @@
 #include "gpio.h"
 #include "uart.h"
 #include "RegionCommon.h"
-
+#include <stdlib.h>
 #include "cli.h"
 #include "Commissioning.h"
 #include "LmHandler.h"
 #include "LmhpCompliance.h"
 #include "CayenneLpp.h"
 #include "LmHandlerMsgDisplay.h"
-
+#include "tvws-board.h"
+#include "scd30.h"
+#define I2C_INTERFACE_SDA                   PB_7
+#define I2C_INTERFACE_SCL                   PB_8
+#include "LoRaMacClassB.h"
+#include "tvws_command.h"
+#include "tvws_at.h"
 #ifndef ACTIVE_REGION
 
 #warning "No active region defined, LORAMAC_REGION_EU868 will be used as default."
@@ -45,6 +51,7 @@
 
 #endif
 
+extern void RtcInit1( uint16_t year, uint8_t month,uint8_t day, uint8_t hour,uint8_t min, uint8_t sec);
 /*!
  * LoRaWAN default end-device class
  */
@@ -55,7 +62,14 @@
 /*!
  * Defines the application data transmission duty cycle. 5s, value in [ms].
  */
+#if REGION_US470
+#define APP_TX_DUTYCYCLE                            30000
+#define SENSOR_TX_DUTYCYCLE                         300000 //5minutes
+
+#else
 #define APP_TX_DUTYCYCLE                            5000
+#endif
+
 
 /*!
  * Defines a random delay for application data transmission duty cycle. 1s,
@@ -68,7 +82,7 @@
  *
  * \remark Please note that when ADR is enabled the end-device should be static
  */
-#define LORAWAN_ADR_STATE                           LORAMAC_HANDLER_ADR_ON
+#define LORAWAN_ADR_STATE                           LORAMAC_HANDLER_ADR_OFF
 
 /*!
  * Default datarate
@@ -99,7 +113,7 @@
  * @remark The allowed port range is from 1 up to 223. Other values are reserved.
  */
 #define LORAWAN_APP_PORT                            2
-
+ 
 /*!
  *
  */
@@ -144,10 +158,13 @@ static TimerEvent_t Led1Timer;
  */
 static TimerEvent_t Led2Timer;
 
+/*!
+ * Timer to handle the state of wait
+ */
+static TimerEvent_t waitTimer;
 /*!
  * Timer to handle the state of LED beacon indicator
  */
-static TimerEvent_t LedBeaconTimer;
 
 static void OnMacProcessNotify( void );
 static void OnNvmDataChange( LmHandlerNvmContextStates_t state, uint16_t size );
@@ -252,11 +269,293 @@ extern Gpio_t Led2; // Rx
  * UART object used for command line interface handling
  */
 extern Uart_t Uart2;
+#ifdef REGION_US470
+        #define TVWS_SENSOR_TIME_PORT 4
+        #define TVWS_BOARD_RESTART_PORT 6
+        #define TVWS_GPS_PORT 8
+        #define TVWS_RFCHAIN_PORT 10
+        uint64_t seconds_elasped= 0;
+        uint8_t beacon_time_check_enabled =1;
+        uint8_t beacon_lost=0;
+        uint8_t tvws_start_loramac =0;
+        uint8_t tvws_start_uplink=0;
+        extern uint8_t tvws_wsdb_registered;
+        uint32_t beacon_freq=0;
+        uint16_t beacon_channel_index=0;
+        uint8_t switch_beacon_channel_enabled=0;
+        uint8_t locked_tvws_beacon=0;
+        
+        uint8_t wait_flag=0;
+        static TimerEvent_t LedBeaconTimer;
+        static const char *conf_msg="Conf mode\n\r";
+        uint32_t rf_chain[2]={0};
+        time_t expiryEpoch=0;
+        float lat=0.0;
+        float lon=0.0;
+        uint8_t tvws_joined=0;
+        uint8_t tvws_registrion_try_count=0;
+        uint8_t on_gps_response=0;
+        uint8_t on_rfchain_response=0;
+        uint32_t stime=0;
+        extern void SetTVWSCM(uint32_t *rf_chain_if_freq);
+        typedef union tagUnion
+        {
+            int32_t val;
+            uint8_t buf[4];
+            /* data */
+        } LBUF;
+        extern void BoardResetMcu();
+        void OnSendRFChainInfoToLNS()
+        {
+            
+             int index=0;
+            LBUF rfcha,rfchb;
+            rfcha.val=rf_chain[RF_CHAIN_A];
+            rfchb.val =rf_chain[RF_CHAIN_B];
+      
+        
+            
+                memset1(AppData.Buffer,0x0,LORAWAN_APP_DATA_BUFFER_MAX_SIZE);
+                AppData.Port=TVWS_RFCHAIN_PORT;
+                AppData.Buffer[index++] = rfcha.buf[0];
+                AppData.Buffer[index++] = rfcha.buf[1];
+                AppData.Buffer[index++] = rfcha.buf[2];
+                AppData.Buffer[index++] = rfcha.buf[3];
+                AppData.Buffer[index++] = rfchb.buf[0];
+                AppData.Buffer[index++] = rfchb.buf[1];
+                AppData.Buffer[index++] = rfchb.buf[2];
+                AppData.Buffer[index++] = rfchb.buf[3];
+                
+                AppData.BufferSize =index;
+            
+                LmHandlerParams.IsTxConfirmed=0;
+            
+                if( LmHandlerSend( &AppData, LmHandlerParams.IsTxConfirmed ) == LORAMAC_HANDLER_SUCCESS )
+                {
+                    // Switch LED 1 ON
+                    GpioWrite( &Led1, 1 );
+                    TimerStart( &Led1Timer );
+                }
+           
+        }
+
 
+        void OnSendGPSInfoToLNS(float latitude, float longitude)
+        {
+             int index=0;
+            LBUF lat2,lon2;
+            lat2.val = ( int32_t ) ( latitude * 10000 );
+            lon2.val= ( int32_t ) ( longitude * 10000 );
+        
+            memset1(AppData.Buffer,0x0,LORAWAN_APP_DATA_BUFFER_MAX_SIZE);
+            AppData.Port=TVWS_GPS_PORT;
+            AppData.Buffer[index++] = lat2.buf[0];
+            AppData.Buffer[index++] = lat2.buf[1];
+            AppData.Buffer[index++] = lat2.buf[2];
+            AppData.Buffer[index++] = lat2.buf[3];
+            AppData.Buffer[index++] = lon2.buf[0];
+            AppData.Buffer[index++] = lon2.buf[1];
+            AppData.Buffer[index++] = lon2.buf[2];
+            AppData.Buffer[index++] = lon2.buf[3];
+            
+            AppData.BufferSize =index;
+        
+            LmHandlerParams.IsTxConfirmed=0;
+        
+            if( LmHandlerSend( &AppData, LmHandlerParams.IsTxConfirmed ) == LORAMAC_HANDLER_SUCCESS )
+            {
+                // Switch LED 1 ON
+                GpioWrite( &Led1, 1 );
+                TimerStart( &Led1Timer );
+            }
+       
+        }
+        void SendWSDBRegistrationRequest( float latitude, float longitude)
+        { 
+            int index=0;
+            LBUF lat2,lon2;
+            lat2.val = ( int32_t ) ( latitude * 10000 );
+            lon2.val= ( int32_t ) ( longitude * 10000 );
+        
+            uint8_t isPending = 0;
+            CRITICAL_SECTION_BEGIN( );
+            isPending = IsTxFramePending;
+            IsTxFramePending = 0;
+            CRITICAL_SECTION_END( );
+            if( isPending == 1 )
+            {
+            memset1(AppData.Buffer,0x0,LORAWAN_APP_DATA_BUFFER_MAX_SIZE);
+            AppData.Port=0;
+            AppData.Buffer[index++] = 0x80; // MAC CID
+            AppData.Buffer[index++] = lat2.buf[0];
+            AppData.Buffer[index++] = lat2.buf[1];
+            AppData.Buffer[index++] = lat2.buf[2];
+            AppData.Buffer[index++] = lat2.buf[3];
+            AppData.Buffer[index++] = lon2.buf[0];
+            AppData.Buffer[index++] = lon2.buf[1];
+            AppData.Buffer[index++] = lon2.buf[2];
+            AppData.Buffer[index++] = lon2.buf[3];
+            
+            AppData.BufferSize =index;
+        
+            LmHandlerParams.IsTxConfirmed=1;
+        
+            if( LmHandlerSend( &AppData, LmHandlerParams.IsTxConfirmed ) == LORAMAC_HANDLER_SUCCESS )
+            {
+                // Switch LED 1 ON
+                GpioWrite( &Led1, 1 );
+                TimerStart( &Led1Timer );
+                tvws_registrion_try_count++;
+                if(tvws_registrion_try_count>20)
+                {
+                    tvws_registrion_try_count=0;
+                     BoardResetMcu(); // restart
+                }
+            }
+        
+            
+            }
+            if(! TimerIsStarted(&TxTimer))
+            {
+                TimerStart(&TxTimer);
+            }
+        }
+        void OnWSDBRegistrationResponse(uint8_t *pdata)
+        {
+            if(pdata[0]==0x81)
+            {
+            
+                rf_chain[RF_CHAIN_A] =(pdata[1] <<24) | (pdata[2] <<16) | (pdata[3] << 8) | pdata[4];
+                rf_chain[RF_CHAIN_B] =(pdata[5] <<24) | (pdata[6] <<16) | (pdata[7] << 8) | pdata[8];
+                expiryEpoch=(pdata[9] <<24) | (pdata[10] <<16) | (pdata[11] << 8) | pdata[12];
+            
+                if( rf_chain[RF_CHAIN_A] >    rf_chain[RF_CHAIN_B]  )
+                {
+                    uint32_t tmp=rf_chain[RF_CHAIN_A] ;
+                    rf_chain[RF_CHAIN_A] =rf_chain[RF_CHAIN_B];
+                    rf_chain[RF_CHAIN_B]  =tmp;
+                }
+                SetTVWSCM(rf_chain);
+                tvws_wsdb_registered =1;
+                CRITICAL_SECTION_BEGIN( );
+                    TxPeriodicity = SENSOR_TX_DUTYCYCLE + randr( -APP_TX_DUTYCYCLE_RND, APP_TX_DUTYCYCLE_RND );
+                    if( TimerIsStarted(&TxTimer))
+                    {
+                        TimerStop(&TxTimer);
+                    }
+                    TimerSetValue( &TxTimer, TxPeriodicity );
+                    TimerStart(&TxTimer);
+                CRITICAL_SECTION_END( );
+                }
+        }
+        void StopBeaconing()
+        {
+            LoRaMacClassBStopRxSlots( );
+        }
+
+        static void OnWaitTimerEvent( void* context )
+        {
+                TimerStop( &waitTimer );
+                wait_flag=1;
+
+        }
+
+        void wait(uint32_t duration)
+        {
+            TimerStop( &waitTimer );
+            TimerSetValue( &waitTimer, duration );
+            wait_flag=0;
+            TimerStart(&waitTimer);
+            while(!wait_flag)
+            {
+            // BoardLowPowerHandler( );
+            }
+        }
+
+        void PollForFactoryResetCommand()
+        {
+            TimerStop( &waitTimer );
+            TimerSetValue( &waitTimer, 15000 );
+            wait_flag=0;
+            TimerStart(&waitTimer);
+            while(!wait_flag)
+            {
+            TVWSBootCLI( &Uart2 );
+            }
+        }
+
+        void SwitchClassB()
+        {
+
+            MlmeReq_t mlmeReq; 
+
+            beacon_lost=0;
+            if(TVWComputeBeaconChannel()!=-1)
+            {
+            
+                
+                SetTVWSBand(RF_STATE_RX_EN_LNA);
+            
+                beacon_channel_index =++beacon_channel_index == 22 ? 0 : beacon_channel_index;
+
+                beacon_freq=  beacon_frequencies[beacon_channel_index];  
+                LoRaMacClassBBeaconFreqReq( beacon_freq);
+        
+                printf("TVWS CH=%d freq set =%ld\r\n",beacon_channel_index,beacon_freq);
+                if(! LoRaMacClassBIsBeaconModeActive())
+                {
+                    mlmeReq.Type = MLME_BEACON_ACQUISITION;
+                    if( LoRaMacMlmeRequest( &mlmeReq ) == LORAMAC_STATUS_OK ) // Initiate beacon acquisition 
+                    { // Service started successfully. Waiting for the Mlme-Confirm event 
+                   
+                    switch_beacon_channel_enabled=0;
+                    } 
+                }
+                }
+
+        }
+        void TVWSStart()
+        {
+
+            if(IsMCURTCInsync())
+            {
+            TVWSGetGPS();
+            
+            switch_beacon_channel_enabled=1;
+        
+            }
+            if(switch_beacon_channel_enabled && ! locked_tvws_beacon)
+            {
+                SwitchClassB();
+            } 
+
+        }
+
+        void TVWSInit()
+        {
+            TVWSInitGPIO();
+            SetTVWSBoardPower(1);
+            SetTVWSGPSState(1);
+            current_rftx_band =CHANNEL_UHF3_GT_458MHz_667MHz; //CHANNEL_868_915_GT_667MHz_960MHz
+            SetTVWSBand(current_rftx_band);
+            SetGPSState(0);
+
+            printf("Starting TVWS \r\n");
+
+            TVWSInitGnss();
+            TWVS_DemoTemperatuerSensorConfig();
+            tvws_start_loramac=0;
+            tvws_start_uplink=1;
+            lat=0.0;
+            lon=0.0;
+        }
+#endif
 /*!
  * Main application entry point.
  */
+ 
 int main( void )
+
 {
     BoardInitMcu( );
     BoardInitPeriph( );
@@ -270,6 +569,8 @@ int main( void )
     TimerInit( &LedBeaconTimer, OnLedBeaconTimerEvent );
     TimerSetValue( &LedBeaconTimer, 5000 );
 
+    TimerInit( &waitTimer, OnWaitTimerEvent );
+    TimerSetValue( &waitTimer, 200 );
     // Initialize transmission periodicity variable
     TxPeriodicity = APP_TX_DUTYCYCLE + randr( -APP_TX_DUTYCYCLE_RND, APP_TX_DUTYCYCLE_RND );
 
@@ -281,35 +582,75 @@ int main( void )
 
     if ( LmHandlerInit( &LmHandlerCallbacks, &LmHandlerParams ) != LORAMAC_HANDLER_SUCCESS )
     {
-        printf( "LoRaMac wasn't properly initialized\n" );
+        printf( "LoRaMac wasn't properly init\n" );
         // Fatal error, endless loop.
         while ( 1 )
         {
         }
     }
-
-    // Set system maximum tolerated rx error in milliseconds
-    LmHandlerSetSystemMaxRxError( 20 );
+    LmHandlerSetSystemMaxRxError(20);
 
     // The LoRa-Alliance Compliance protocol package should always be
     // initialized and activated.
     LmHandlerPackageRegister( PACKAGE_ID_COMPLIANCE, &LmhpComplianceParams );
-
+    scd30_init(I2C_INTERFACE_SDA, I2C_INTERFACE_SCL, 400000)  ;
+#ifdef REGION_US470
+    
+    TVWSCli_Init(NULL);
+    PollForFactoryResetCommand();
+    LmHandlerSetTxPower(9); //18 EIRP
+    if(!IsValidDevEUI())
+    {
+        UartPutBuffer( &Uart2,conf_msg, 11 );
+        TVWSConfigCLI( &Uart2 );
+    }
+    TVWSInit();
+   // scd30_init(I2C_INTERFACE_SDA, I2C_INTERFACE_SCL, 400000)  ;
+    
+    TVWSStart();
+     while(!tvws_start_loramac) {
+        CliProcess( &Uart2 );
+        LmHandlerProcess( );
+        if(beacon_lost)
+        {
+             TVWSStart();
+        }
+     }
+     tvws_start_uplink=1;
+#else
     LmHandlerJoin( );
-
-    StartTxProcess( LORAMAC_HANDLER_TX_ON_TIMER );
-
+#endif    
+  //  
+     StartTxProcess( LORAMAC_HANDLER_TX_ON_TIMER );
     while( 1 )
     {
         // Process characters sent over the command line interface
         CliProcess( &Uart2 );
-
+     
         // Processes the LoRaMac events
         LmHandlerProcess( );
 
         // Process application uplinks management
-        UplinkProcess( );
-
+    #ifdef REGION_US470
+       if(tvws_start_uplink)
+       {
+        if(tvws_wsdb_registered)
+        {
+           
+            
+                UplinkProcess( );
+        
+           
+        }
+        else
+        {
+                SendWSDBRegistrationRequest(lat,lon); // Join Request checked in the send function
+               
+        }
+       }
+    #else
+          UplinkProcess( );
+    #endif 
         CRITICAL_SECTION_BEGIN( );
         if( IsMacProcessPending == 1 )
         {
@@ -319,7 +660,7 @@ int main( void )
         else
         {
             // The MCU wakes up through events
-            BoardLowPowerHandler( );
+        BoardLowPowerHandler( );
         }
         CRITICAL_SECTION_END( );
     }
@@ -352,6 +693,7 @@ static void OnMacMlmeRequest( LoRaMacStatus_t status, MlmeReq_t *mlmeReq, TimerT
 
 static void OnJoinRequest( LmHandlerJoinParams_t* params )
 {
+     
     DisplayJoinRequestUpdate( params );
     if( params->Status == LORAMAC_HANDLER_ERROR )
     {
@@ -365,6 +707,7 @@ static void OnJoinRequest( LmHandlerJoinParams_t* params )
 
 static void OnTxData( LmHandlerTxParams_t* params )
 {
+     SetTVWSBand(ALL_OFF);
     DisplayTxUpdate( params );
 }
 
@@ -374,12 +717,62 @@ static void OnRxData( LmHandlerAppData_t* appData, LmHandlerRxParams_t* params )
 
     switch( appData->Port )
     {
+    case 0:
+    break;
     case 1: // The application LED can be controlled on port 1 or 2
     case LORAWAN_APP_PORT:
         {
             AppLedStateOn = appData->Buffer[0] & 0x01;
         }
         break;
+    #ifdef REGION_US470
+        case TVWS_SENSOR_TIME_PORT:
+                if(appData->BufferSize==8)
+                { 
+                    appData->Buffer[8]=0;
+                    stime=0;
+                    stime = strtol( ( const char *)appData->Buffer, NULL, 16);
+
+               
+               if(stime < 1 )
+                {
+                    stime=5000;
+                }
+                else if(stime > 86400)
+                {
+                    stime=5000;
+                }
+                CRITICAL_SECTION_BEGIN( );
+                    
+                        TxPeriodicity = stime + randr( -APP_TX_DUTYCYCLE_RND, APP_TX_DUTYCYCLE_RND );
+                        if( TimerIsStarted(&TxTimer))
+                        {
+                            TimerStop(&TxTimer);
+                        }
+                        TimerSetValue( &TxTimer, TxPeriodicity );
+                        TimerStart(&TxTimer);
+                CRITICAL_SECTION_END( );
+                }
+        break;
+        case TVWS_BOARD_RESTART_PORT:
+                if(appData->Buffer[0]=='R' && appData->Buffer[1]=='S' && appData->Buffer[2]=='T')
+                {
+                    BoardResetMcu();
+                }
+            break;
+        case TVWS_GPS_PORT:
+                if(appData->Buffer[0]=='G')
+                {
+                    on_gps_response=1;
+                }
+        break;
+             case TVWS_RFCHAIN_PORT:
+                if(appData->Buffer[0]=='C')
+                {
+                    on_rfchain_response=1;
+                }
+        break;
+    #endif
     default:
         break;
     }
@@ -410,11 +803,24 @@ static void OnBeaconStatusChange( LoRaMacHandlerBeaconParams_t* params )
         case LORAMAC_HANDLER_BEACON_RX:
         {
             TimerStart( &LedBeaconTimer );
+           // TVWSSetGnssState(0);
+           if(locked_tvws_beacon)
+           {
+                rf_chain[RF_CHAIN_A]=params->Info.Frequency;
+                rf_chain[RF_CHAIN_B]=0;
+                SetTVWSCM(rf_chain);
+                tvws_start_loramac=1;
+                tvws_start_uplink=0;
+
+        
+           }
             break;
         }
         case LORAMAC_HANDLER_BEACON_LOST:
         case LORAMAC_HANDLER_BEACON_NRX:
         {
+           // TVWSSetGnssState(1);
+          
             TimerStop( &LedBeaconTimer );
             break;
         }
@@ -444,22 +850,67 @@ static void OnSysTimeUpdate( void )
  */
 static void PrepareTxFrame( void )
 {
+    float scd_temperature =0.0;
+    float scd_humidity=0.0;
+    float scd_co2val=0.0;
+    uint32_t scd_temperaturei =0;
+    uint32_t scd_humidityi=0;
+    uint32_t scd_co2vali=0;
+    uint16_t adc_a=0;
+    uint16_t adc_b=0;
+    float batterylevel=BoardGetBatteryLevel( ) * 100 / 254 ;
     if( LmHandlerIsBusy( ) == true )
     {
         return;
     }
 
-    uint8_t channel = 0;
+   Read_SCD30(&scd_temperature,&scd_humidity,&scd_co2val);
+    adc_a =  TVWS_ReadADC(TVWS_SENSOR_ADC_A);
+    adc_b= TVWS_ReadADC(TVWS_SENSOR_ADC_B);
+    uint8_t channel = 0; 
+    uint16_t temperature=(uint16_t)TWVS_DemoTemperatureSensorRead();
+    printf( "Temperature degC %3d\r\n",temperature );
+    printf( "Battery level %3d\r\n",(int)batterylevel );
+    printf( "ADC A count %04X\r\n",adc_a );
+    printf( "ADC B count %04X\r\n",adc_b );
+  
+   
+    printf( "Temperature degC %3.2f\r\n",scd_temperature );
+    printf( "Humidity pctRH %3.2f\r\n",scd_humidity );
+    printf( "CO2 ppm %3.2f\r\n",scd_co2val );
+    
+
+
+
+   Read_SCD30i(&scd_temperaturei,&scd_humidityi,&scd_co2vali);
+  
+
+   
+    printf( "iTemperature degC %ld\r\n",scd_temperaturei );
+    printf( "iHumidity pctRH %ld\r\n",scd_humidityi );
+    printf( "iCO2 ppm %ld\r\n",scd_co2vali );
+    
+     
 
-    AppData.Port = LORAWAN_APP_PORT;
 
     CayenneLppReset( );
-    CayenneLppAddDigitalInput( channel++, AppLedStateOn );
-    CayenneLppAddAnalogInput( channel++, BoardGetBatteryLevel( ) * 100 / 254 );
+ 
+
+ 
+    // CayenneLppAddDigitalInput( channel++, AppLedStateOn );
+    CayenneLppAddTemperature(channel++,temperature);
+    CayenneLppAddAnalogInput( channel++,batterylevel );
+    CayenneLppAddGenericADCSensor( channel++,adc_a );
+    CayenneLppAddGenericADCSensor( channel++,adc_b );
+   
+    CayenneLppAddTemperature(channel++,scd_temperature);
+    CayenneLppAddRelativeHumidity(channel++,scd_humidity);
+    CayenneLppAddGenericSensor(channel++,scd_co2val);
 
     CayenneLppCopy( AppData.Buffer );
+    AppData.Port = LORAWAN_APP_PORT;
     AppData.BufferSize = CayenneLppGetSize( );
-
+    LmHandlerParams.IsTxConfirmed=0;
     if( LmHandlerSend( &AppData, LmHandlerParams.IsTxConfirmed ) == LORAMAC_HANDLER_SUCCESS )
     {
         // Switch LED 1 ON
@@ -497,8 +948,28 @@ static void UplinkProcess( void )
     IsTxFramePending = 0;
     CRITICAL_SECTION_END( );
     if( isPending == 1 )
-    {
+    {  
+      #ifdef REGION_US470  
+      if( ! CheckWSDBExpiry(expiryEpoch))
+        {
+             if(on_gps_response)
+            {
+                on_gps_response=0;
+                OnSendGPSInfoToLNS(lat,lon);
+            }
+            else if(on_rfchain_response)
+            {
+                on_rfchain_response=0;
+                OnSendRFChainInfoToLNS();
+            }
+            else
+            {
+                 PrepareTxFrame( );
+            }
+    }
+    #else
         PrepareTxFrame( );
+    #endif
     }
 }
 
@@ -567,7 +1038,7 @@ static void OnLed2TimerEvent( void* context )
 static void OnLedBeaconTimerEvent( void* context )
 {
     GpioWrite( &Led2, 1 );
-    TimerStart( &Led2Timer );
+ //   TimerStart( &Led2Timer );
 
-    TimerStart( &LedBeaconTimer );
+  //  TimerStart( &LedBeaconTimer );
 }
diff --git a/src/boards/NucleoL152/CMakeLists.txt b/src/boards/NucleoL152/CMakeLists.txt
index 85facc95..61a19878 100644
--- a/src/boards/NucleoL152/CMakeLists.txt
+++ b/src/boards/NucleoL152/CMakeLists.txt
@@ -35,7 +35,13 @@ list(APPEND ${PROJECT_NAME}_SOURCES
     "${CMAKE_CURRENT_SOURCE_DIR}/spi-board.c"
     "${CMAKE_CURRENT_SOURCE_DIR}/sysIrqHandlers.c"
     "${CMAKE_CURRENT_SOURCE_DIR}/uart-board.c"
+
     "${CMAKE_CURRENT_SOURCE_DIR}/../mcu/utilities.c"
+    "${CMAKE_CURRENT_SOURCE_DIR}/../../apps/LoRaMac/common/tvws-board.c"
+    "${CMAKE_CURRENT_SOURCE_DIR}/../../apps/LoRaMac/common/stm32_tiny_sscanf.c"
+    "${CMAKE_CURRENT_SOURCE_DIR}/../../apps/LoRaMac/common/tvws_at.c"
+    "${CMAKE_CURRENT_SOURCE_DIR}/../../apps/LoRaMac/common/tvws_command.c"
+    "${CMAKE_CURRENT_SOURCE_DIR}/../../apps/LoRaMac/common/scd30.c"
     "${CMAKE_CURRENT_SOURCE_DIR}/cmsis/arm-gcc/startup_stm32l152xe.s"
     "${CMAKE_CURRENT_SOURCE_DIR}/cmsis/system_stm32l1xx.c"
     "${CMAKE_CURRENT_SOURCE_DIR}/../mcu/stm32/STM32L1xx_HAL_Driver/Src/stm32l1xx_hal.c"
@@ -92,6 +98,8 @@ target_include_directories(${PROJECT_NAME} PUBLIC
     ${CMAKE_CURRENT_SOURCE_DIR}/../mcu/stm32
     ${CMAKE_CURRENT_SOURCE_DIR}/../mcu/stm32/cmsis
     ${CMAKE_CURRENT_SOURCE_DIR}/../mcu/stm32/STM32L1xx_HAL_Driver/Inc
+    ${CMAKE_CURRENT_SOURCE_DIR}/../../apps/LoRaMac/common
+    ${CMAKE_CURRENT_SOURCE_DIR}/../../apps/LoRaMac/common/LmHandler
     $<TARGET_PROPERTY:board,INTERFACE_INCLUDE_DIRECTORIES>
     $<TARGET_PROPERTY:system,INTERFACE_INCLUDE_DIRECTORIES>
     $<TARGET_PROPERTY:radio,INTERFACE_INCLUDE_DIRECTORIES>
diff --git a/src/boards/NucleoL152/board-config.h b/src/boards/NucleoL152/board-config.h
index 8b853839..efaddf1f 100644
--- a/src/boards/NucleoL152/board-config.h
+++ b/src/boards/NucleoL152/board-config.h
@@ -44,7 +44,7 @@ extern "C"
 #if defined( SX1262MBXDAS )
 #define BOARD_TCXO_WAKEUP_TIME                      5
 #else
-#define BOARD_TCXO_WAKEUP_TIME                      0
+#define BOARD_TCXO_WAKEUP_TIME                      5
 #endif
 
 /*!
@@ -124,6 +124,8 @@ extern "C"
 #define UART_TX                                     PA_2
 #define UART_RX                                     PA_3
 
+
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/boards/NucleoL152/board.c b/src/boards/NucleoL152/board.c
index c8ab5376..bdbadea1 100644
--- a/src/boards/NucleoL152/board.c
+++ b/src/boards/NucleoL152/board.c
@@ -32,7 +32,10 @@
 #include "board-config.h"
 #include "lpm-board.h"
 #include "rtc-board.h"
+#ifndef TVWS_RADIO
 
+#define TVWS_RADIO
+#endif
 #if defined( SX1261MBXBAS ) || defined( SX1262MBXCAS ) || defined( SX1262MBXDAS )
     #include "sx126x-board.h"
 #elif defined( LR1110MB1XXS )
@@ -135,7 +138,8 @@ void BoardInitMcu( void )
         FifoInit( &Uart2.FifoRx, Uart2RxBuffer, UART2_FIFO_RX_SIZE );
         // Configure your terminal for 8 Bits data (7 data bit + 1 parity bit), no parity and no flow ctrl
         UartInit( &Uart2, UART_2, UART_TX, UART_RX );
-        UartConfig( &Uart2, RX_TX, 921600, UART_8_BIT, UART_1_STOP_BIT, NO_PARITY, NO_FLOW_CTRL );
+       // UartConfig( &Uart2, RX_TX, 921600, UART_8_BIT, UART_1_STOP_BIT, NO_PARITY, NO_FLOW_CTRL );
+    UartConfig( &Uart2, RX_TX, 115200, UART_8_BIT, UART_1_STOP_BIT, NO_PARITY, NO_FLOW_CTRL );
 
         RtcInit( );
 
@@ -152,8 +156,14 @@ void BoardInitMcu( void )
     }
 
     AdcInit( &Adc, NC );  // Just initialize ADC
-
-#if defined( SX1261MBXBAS ) || defined( SX1262MBXCAS ) || defined( SX1262MBXDAS )
+#if defined(TVWS_RADIO)
+    #include "tvws-board.h"
+ 
+    SpiInit( &SX126x.Spi, SPI_1, TVWS_RADIO_MOSI, TVWS_RADIO_MISO, TVWS_RADIO_SCLK, NC );
+  //  TVWSSPIInit();
+     SX126xIoInit( );
+     
+#elif defined( SX1261MBXBAS ) || defined( SX1262MBXCAS ) || defined( SX1262MBXDAS )
     SpiInit( &SX126x.Spi, SPI_1, RADIO_MOSI, RADIO_MISO, RADIO_SCLK, NC );
     SX126xIoInit( );
 #elif defined( LR1110MB1XXS )
diff --git a/src/boards/NucleoL152/i2c-board.c b/src/boards/NucleoL152/i2c-board.c
index 41ab06ad..42e41c26 100644
--- a/src/boards/NucleoL152/i2c-board.c
+++ b/src/boards/NucleoL152/i2c-board.c
@@ -121,7 +121,7 @@ LmnStatus_t I2cMcuReadBuffer( I2c_t *obj, uint8_t deviceAddr, uint8_t *buffer, u
     status = ( HAL_I2C_Master_Receive( &I2cHandle, deviceAddr, buffer, size, 2000 ) == HAL_OK ) ? LMN_STATUS_OK : LMN_STATUS_ERROR;
 
     return status;
-}
+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }
 
 LmnStatus_t I2cMcuWriteMemBuffer( I2c_t *obj, uint8_t deviceAddr, uint16_t addr, uint8_t *buffer, uint16_t size )
 {
diff --git a/src/boards/NucleoL152/rtc-board.c b/src/boards/NucleoL152/rtc-board.c
index df6dc5d8..38809fda 100644
--- a/src/boards/NucleoL152/rtc-board.c
+++ b/src/boards/NucleoL152/rtc-board.c
@@ -34,7 +34,7 @@
 #include "sysIrqHandlers.h"
 #include "lpm-board.h"
 #include "rtc-board.h"
-
+#include "stm32l1xx_hal_rtc.h"
 // MCU Wake Up Time
 #define MIN_ALARM_DELAY                             3 // in ticks
 
@@ -568,3 +568,91 @@ TimerTime_t RtcTempCompensation( TimerTime_t period, float temperature )
     // Calculate the resulting period
     return ( TimerTime_t ) interim;
 }
+void RtcGetTime(struct tm *time_struct)
+{
+     RTC_TimeTypeDef time;
+    RTC_DateTypeDef date;
+
+    uint32_t calendarValue = ( uint32_t )RtcGetCalendarValue( &date, &time );
+
+    time_struct->tm_hour=time.Hours;
+    time_struct->tm_min=time.Minutes;
+    time_struct->tm_sec=time.Seconds;
+    time_struct->tm_year=date.Year;
+    time_struct->tm_mon=date.Month;
+    time_struct->tm_mday=date.Date;
+}
+void RtcSetTime(struct tm *time_struct)
+{
+     RTC_TimeTypeDef time;
+    RTC_DateTypeDef date;
+        date.Year                     = time_struct->tm_year -100;
+        date.Month                    =  time_struct->tm_mon +1;
+        date.Date                     =  time_struct->tm_mday;
+        //date.WeekDay                  = RTC_WEEKDAY_MONDAY;
+        HAL_RTC_SetDate( &RtcHandle, &date, RTC_FORMAT_BIN );
+
+        /*at 0:0:0*/
+        time.Hours                    = time_struct->tm_hour;
+        time.Minutes                  = time_struct->tm_min;
+        time.Seconds                  = time_struct->tm_sec;
+        time.SubSeconds               = 0;
+        time.TimeFormat               = 0;
+        time.StoreOperation           = RTC_STOREOPERATION_RESET;
+        time.DayLightSaving           = RTC_DAYLIGHTSAVING_NONE;
+        HAL_RTC_SetTime( &RtcHandle, &time, RTC_FORMAT_BIN );
+
+RtcGetTime(time_struct);
+
+
+}
+ 
+void GetRTCDateTime(struct tm *time_struct)
+{
+ 
+RTC_TimeTypeDef RTC_TimeStructure;
+RTC_DateTypeDef RTC_DateStructure;
+ 
+
+
+    // Get RTC time
+     HAL_RTC_GetTime( &RtcHandle, &RTC_TimeStructure, RTC_FORMAT_BIN );
+        time_struct->tm_hour=RTC_TimeStructure.Hours;
+        time_struct->tm_min = RTC_TimeStructure.Minutes;
+        time_struct->tm_sec =    RTC_TimeStructure.Seconds ;
+  
+
+    // Get RTC date
+     HAL_RTC_GetDate( &RtcHandle, &RTC_DateStructure, RTC_FORMAT_BIN );
+    time_struct->tm_year = RTC_DateStructure.Year;
+    time_struct->tm_mon = RTC_DateStructure.Month;
+     time_struct->tm_mday = RTC_DateStructure.Date;
+ 
+   
+}
+
+void SetRTCDateTime(uint8_t year, uint8_t month, uint8_t day, uint8_t hour, uint8_t minute, uint8_t second)
+{
+ 
+RTC_TimeTypeDef RTC_TimeStructure;
+RTC_DateTypeDef RTC_DateStructure;
+    // Enable RTC clock and enter initialization mode
+    RTC_EnterInitMode(&RtcHandle);
+
+ 
+
+    // Set RTC time
+    RTC_TimeStructure.Hours = hour;
+    RTC_TimeStructure.Minutes = minute;
+    RTC_TimeStructure.Seconds = second;
+    HAL_RTC_SetTime( &RtcHandle, &RTC_TimeStructure, RTC_FORMAT_BIN );
+
+
+    // Set RTC date
+    RTC_DateStructure.Year = year;
+    RTC_DateStructure.Month = month;
+    RTC_DateStructure.WeekDay =0;
+    RTC_DateStructure.Date = day;
+  
+    HAL_RTC_SetDate( &RtcHandle, &RTC_DateStructure, RTC_FORMAT_BIN );
+}
\ No newline at end of file
diff --git a/src/mac/CMakeLists.txt b/src/mac/CMakeLists.txt
index 9a87ad74..99fd4133 100644
--- a/src/mac/CMakeLists.txt
+++ b/src/mac/CMakeLists.txt
@@ -23,7 +23,7 @@ cmake_minimum_required(VERSION 3.6)
 #---------------------------------------------------------------------------------------
 
 # Allow selection of region
-option(REGION_EU868 "Region EU868" ON)
+option(REGION_EU868 "Region EU868" OFF)
 option(REGION_US915 "Region US915" OFF)
 option(REGION_CN779 "Region CN779" OFF)
 option(REGION_EU433 "Region EU433" OFF)
@@ -33,7 +33,8 @@ option(REGION_CN470 "Region CN470" OFF)
 option(REGION_KR920 "Region KR920" OFF)
 option(REGION_IN865 "Region IN865" OFF)
 option(REGION_RU864 "Region RU864" OFF)
-set(REGION_LIST REGION_EU868 REGION_US915 REGION_CN779 REGION_EU433 REGION_AU915 REGION_AS923 REGION_CN470 REGION_KR920 REGION_IN865 REGION_RU864)
+option(REGION_US470 "Region US470" ON)
+set(REGION_LIST REGION_EU868 REGION_US915 REGION_CN779 REGION_EU433 REGION_AU915 REGION_AS923 REGION_CN470 REGION_KR920 REGION_IN865 REGION_RU864 REGION_US470)
 
 # AS923 Channel Plan
 set(REGION_AS923_DEFAULT_CHANNEL_PLAN_LIST CHANNEL_PLAN_GROUP_AS923_1 CHANNEL_PLAN_GROUP_AS923_2 CHANNEL_PLAN_GROUP_AS923_3 CHANNEL_PLAN_GROUP_AS923_4 CHANNEL_PLAN_GROUP_AS923_1_JP)
@@ -75,6 +76,12 @@ set( MAC_BUILD_SOURCES
      "${CMAKE_CURRENT_SOURCE_DIR}/region/RegionUS915.c" )
 endif()
 
+if(REGION_US470 STREQUAL ON)
+set( MAC_BUILD_SOURCES
+     ${MAC_BUILD_SOURCES}
+     "${CMAKE_CURRENT_SOURCE_DIR}/region/RegionUS470.c" )
+endif()
+
 if(REGION_AU915 STREQUAL ON)
 set( MAC_BUILD_SOURCES
      ${MAC_BUILD_SOURCES}
diff --git a/src/mac/LoRaMac.c b/src/mac/LoRaMac.c
index c481e8cd..e560c7d5 100644
--- a/src/mac/LoRaMac.c
+++ b/src/mac/LoRaMac.c
@@ -45,9 +45,9 @@
 #include "LoRaMacAdr.h"
 #include "LoRaMacSerializer.h"
 #include "radio.h"
-
+#include "LmHandlerTypes.h"
 #include "LoRaMac.h"
-
+#include <stdio.h>
 /*!
  * Maximum PHY layer payload size
  */
@@ -197,6 +197,7 @@ typedef struct sLoRaMacCtx
      * Current channel index
      */
     uint8_t Channel;
+    
     /*
     * Last transmission time on air
     */
@@ -507,7 +508,10 @@ static void RemoveMacCommands( LoRaMacRxSlot_t rxSlot, LoRaMacFrameCtrl_t fCtrl,
  * \param [IN] channel     Channel to transmit on
  * \retval status          Status of the operation.
  */
+ 
+ 
 LoRaMacStatus_t SendFrameOnChannel( uint8_t channel );
+ 
 
 /*!
  * \brief Sets the radio in continuous transmission mode
@@ -752,6 +756,7 @@ static void OnRadioTxDone( void )
 
 static void OnRadioRxDone( uint8_t *payload, uint16_t size, int16_t rssi, int8_t snr )
 {
+    // printf("OnRxDone\r\n");
     RxDoneParams.LastRxDone = TimerGetCurrentTime( );
     RxDoneParams.Payload = payload;
     RxDoneParams.Size = size;
@@ -779,6 +784,7 @@ static void OnRadioTxTimeout( void )
 
 static void OnRadioRxError( void )
 {
+  //   printf("OnRxError\r\n");
     LoRaMacRadioEvents.Events.RxError = 1;
 
     if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
@@ -789,6 +795,7 @@ static void OnRadioRxError( void )
 
 static void OnRadioRxTimeout( void )
 {
+  //  printf("\tOnRxTimeout\r\n");
     LoRaMacRadioEvents.Events.RxTimeout = 1;
 
     if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
@@ -857,6 +864,7 @@ static void ProcessRadioTxDone( void )
 
 static void PrepareRxDoneAbort( void )
 {
+   // printf("RXDoneAbort");
     MacCtx.MacState |= LORAMAC_RX_ABORT;
 
     if( MacCtx.NodeAckRequested == true )
@@ -975,12 +983,14 @@ static void ProcessRadioRxDone( void )
                 PrepareRxDoneAbort( );
                 return;
             }
-            macCryptoStatus = LoRaMacCryptoHandleJoinAccept( JOIN_REQ, SecureElementGetJoinEui( ), &macMsgJoinAccept );
-
+       
             VerifyParams_t verifyRxDr;
             bool rxDrValid = false;
             verifyRxDr.DatarateParams.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;
             verifyRxDr.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
+            
+            macCryptoStatus = LoRaMacCryptoHandleJoinAccept( JOIN_REQ, SecureElementGetJoinEui( ), &macMsgJoinAccept );
+
             rxDrValid = RegionVerify( Nvm.MacGroup2.Region, &verifyRxDr, PHY_RX_DR );
 
             if( ( LORAMAC_CRYPTO_SUCCESS == macCryptoStatus ) && ( rxDrValid == true ) )
@@ -1056,6 +1066,7 @@ static void ProcessRadioRxDone( void )
             }
             else
             {
+               // printf("\tInvalid RX DR\r\n");
                 // MLME handling
                 if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
                 {
@@ -1640,8 +1651,10 @@ static void LoRaMacHandleMlmeRequest( void )
         {
             if( LoRaMacConfirmQueueGetStatus( MLME_JOIN ) == LORAMAC_EVENT_INFO_STATUS_OK )
             {// Node joined successfully
+              //  printf("\tJoined\r\n");
                 MacCtx.ChannelsNbTransCounter = 0;
             }
+          
             MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
         }
         else if( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW ) == true )
@@ -1868,6 +1881,7 @@ static void OnRxWindow2TimerEvent( void* context )
     {
         return;
     }
+      MacCtx.RxWindow2Config.DrOffset=1;
     MacCtx.RxWindow2Config.Channel = MacCtx.Channel;
     MacCtx.RxWindow2Config.Frequency = Nvm.MacGroup2.MacParams.Rx2Channel.Frequency;
     MacCtx.RxWindow2Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
@@ -1952,8 +1966,6 @@ static LoRaMacStatus_t SwitchClass( DeviceClass_t deviceClass )
             {
                 // Revert back RxC parameters
                 Nvm.MacGroup2.MacParams.RxCChannel = Nvm.MacGroup2.MacParams.Rx2Channel;
-
-                status = LORAMAC_STATUS_OK;
             }
             if( deviceClass == CLASS_B )
             {
@@ -2495,6 +2507,7 @@ static void ProcessMacCommands( uint8_t *payload, uint8_t macIndex, uint8_t comm
 
                     // Apply the new system time.
                     SysTimeSet( sysTime );
+                    // TODO: Do make sure to call this function when we lock time from GPS module
                     LoRaMacClassBDeviceTimeAns( );
                     MacCtx.McpsIndication.DeviceTimeAnsReceived = true;
                 }
@@ -2572,6 +2585,14 @@ static void ProcessMacCommands( uint8_t *payload, uint8_t macIndex, uint8_t comm
                     LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_FREQ_ANS, macCmdPayload, 1 );
                 }
                 break;
+                #ifdef REGION_US470
+                case SRV_MAC_WSDB_REQUEST_ANS:
+                {
+                    extern void OnWSDBRegistrationResponse(uint8_t *pdata);
+                      OnWSDBRegistrationResponse(payload);
+                }
+                break;
+             #endif
             default:
                 // Unknown command. ABORT MAC commands processing
                 return;
@@ -2808,6 +2829,7 @@ static void ComputeRxWindowParameters( void )
     {
         MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay1 + MacCtx.RxWindow1Config.WindowOffset;
         MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay2 + MacCtx.RxWindow2Config.WindowOffset;
+       // printf("RXDly=%d\r\n",  MacCtx.RxWindow1Delay );
     }
 }
 
@@ -2864,7 +2886,13 @@ static LoRaMacStatus_t ScheduleTx( bool allowDelayedTx )
 {
     LoRaMacStatus_t status = LORAMAC_STATUS_PARAMETER_INVALID;
     NextChanParams_t nextChan;
-
+#ifdef REGION_US470
+extern uint8_t tvws_start_uplink;
+    if(!tvws_start_uplink)
+    {
+        return LORAMAC_STATUS_OK;// LORAMAC_STATUS_ERROR; // not allowed to tx unless TVWS channel masking is ste
+    }
+#endif
     // Check class b collisions
     status = CheckForClassBCollision( );
     if( status != LORAMAC_STATUS_OK )
@@ -2903,22 +2931,18 @@ static LoRaMacStatus_t ScheduleTx( bool allowDelayedTx )
 
     if( status != LORAMAC_STATUS_OK )
     {
-        if( status == LORAMAC_STATUS_DUTYCYCLE_RESTRICTED )
+        if( ( status == LORAMAC_STATUS_DUTYCYCLE_RESTRICTED ) &&
+            ( allowDelayedTx == true ) )
         {
+            // Allow delayed transmissions. We have to allow it in case
+            // the MAC must retransmit a frame with the frame repetitions
             if( MacCtx.DutyCycleWaitTime != 0 )
-            {
-                if( allowDelayedTx == true )
-                {
-                    // Allow delayed transmissions. We have to allow it in case
-                    // the MAC must retransmit a frame with the frame repetitions
-                    MacCtx.MacState |= LORAMAC_TX_DELAYED;
-                    TimerSetValue( &MacCtx.TxDelayedTimer, MacCtx.DutyCycleWaitTime );
-                    TimerStart( &MacCtx.TxDelayedTimer );
-                    return LORAMAC_STATUS_OK;
-                }
-                // Need to delay, but allowDelayedTx does not allow it
-                return status;
+            {// Send later - prepare timer
+                MacCtx.MacState |= LORAMAC_TX_DELAYED;
+                TimerSetValue( &MacCtx.TxDelayedTimer, MacCtx.DutyCycleWaitTime );
+                TimerStart( &MacCtx.TxDelayedTimer );
             }
+            return LORAMAC_STATUS_OK;
         }
         else
         {// State where the MAC cannot send a frame
@@ -3272,8 +3296,9 @@ LoRaMacStatus_t PrepareFrame( LoRaMacHeader_t* macHdr, LoRaMacFrameCtrl_t* fCtrl
 
     return LORAMAC_STATUS_OK;
 }
-
+ 
 LoRaMacStatus_t SendFrameOnChannel( uint8_t channel )
+ 
 {
     LoRaMacStatus_t status = LORAMAC_STATUS_PARAMETER_INVALID;
     TxConfigParams_t txConfig;
@@ -5425,3 +5450,4 @@ LoRaMacStatus_t LoRaMacDeInitialization( void )
         return LORAMAC_STATUS_BUSY;
     }
 }
+
diff --git a/src/mac/LoRaMac.h b/src/mac/LoRaMac.h
index ef408ca8..2e748d9b 100644
--- a/src/mac/LoRaMac.h
+++ b/src/mac/LoRaMac.h
@@ -558,6 +558,10 @@ typedef enum eLoRaMacRegion
      * Russia band on 864MHz
      */
     LORAMAC_REGION_RU864,
+    /*!
+     * North american UHF TV band
+     */
+    LORAMAC_REGION_US470,
 }LoRaMacRegion_t;
 
 typedef struct sLoRaMacNvmDataGroup1
diff --git a/src/mac/LoRaMacClassB.c b/src/mac/LoRaMacClassB.c
index b31b3617..6211e4bb 100644
--- a/src/mac/LoRaMacClassB.c
+++ b/src/mac/LoRaMacClassB.c
@@ -31,7 +31,9 @@ Maintainer: Miguel Luis ( Semtech ), Gregory Cristian ( Semtech ) and Daniel Jae
 
 #ifdef LORAMAC_CLASSB_ENABLED
 
-
+     #ifdef REGION_US470
+     #include "tvws-board.h"
+     #endif
 /*
  * LoRaMac Class B Context structure
  */
@@ -163,6 +165,7 @@ static void ComputePingOffset( uint64_t beaconTime, uint32_t address, uint16_t p
  *
  * \retval The downlink frequency
  */
+ 
 static uint32_t CalcDownlinkFrequency( uint8_t channel, bool isBeacon )
 {
     GetPhyParams_t getPhy;
@@ -203,7 +206,13 @@ static uint32_t CalcDownlinkChannelAndFrequency( uint32_t devAddr, TimerTime_t b
     uint32_t channel = 0;
     uint8_t nbChannels = 0;
     uint8_t offset = 0;
-
+ #ifdef REGION_US470 
+    if(devAddr==0)
+    {
+         extern uint32_t beacon_freq;
+         return beacon_freq;
+    }
+   #endif
     // Default initialization - ping slot channels
     getPhy.Attribute = PHY_PING_SLOT_NB_CHANNELS;
 
@@ -215,6 +224,8 @@ static uint32_t CalcDownlinkChannelAndFrequency( uint32_t devAddr, TimerTime_t b
     phyParam = RegionGetPhyParam( *Ctx.LoRaMacClassBParams.LoRaMacRegion, &getPhy );
     nbChannels = ( uint8_t ) phyParam.Value;
 
+
+
     // nbChannels is > 1, when the channel plan requires more than one possible channel
     // defined by the calculation below.
     if( nbChannels > 1 )
@@ -231,7 +242,10 @@ static uint32_t CalcDownlinkChannelAndFrequency( uint32_t devAddr, TimerTime_t b
 
     // Calculate the frequency for the next downlink. This holds
     // for beacons and ping slots.
+   
+
     return CalcDownlinkFrequency( channel, isBeacon );
+  
 }
 
 /*!
@@ -299,8 +313,25 @@ static void RxBeaconSetup( TimerTime_t rxTime, bool activateDefaultChannel, uint
     else
     {
         // This is the frequency according to the channel plan
-        frequency = CalcDownlinkChannelAndFrequency( 0, Ctx.BeaconCtx.BeaconTime.Seconds + ( CLASSB_BEACON_INTERVAL / 1000 ),
+        #ifdef REGION_US470
+          
+          extern uint8_t tvws_joined;
+          uint32_t devAddr= 0;
+          if(tvws_joined)
+          { 
+            MibRequestConfirm_t mibReq;
+            mibReq.Type = MIB_DEV_ADDR;
+            LoRaMacMibGetRequestConfirm( &mibReq );
+            devAddr= mibReq.Param.DevAddr ;
+          }
+           
+             frequency = CalcDownlinkChannelAndFrequency( devAddr, Ctx.BeaconCtx.BeaconTime.Seconds + ( CLASSB_BEACON_INTERVAL / 1000 ),
+                                                     CLASSB_BEACON_INTERVAL, true );
+        #else
+              frequency = CalcDownlinkChannelAndFrequency( 0, Ctx.BeaconCtx.BeaconTime.Seconds + ( CLASSB_BEACON_INTERVAL / 1000 ),
                                                      CLASSB_BEACON_INTERVAL, true );
+        #endif
+      
     }
 
     if( ClassBNvm->BeaconCtx.Ctrl.CustomFreq == 1 )
@@ -701,6 +732,10 @@ void LoRaMacClassBBeaconTimerEvent( void* context )
 #ifdef LORAMAC_CLASSB_ENABLED
     Ctx.BeaconCtx.TimeStamp = TimerGetCurrentTime( );
     TimerStop( &Ctx.BeaconTimer );
+    #ifdef REGION_US470
+         //   printf("BT-STP%d\r\n");
+            switch_beacon_channel_enabled=1;
+        #endif
     LoRaMacClassBEvents.Events.Beacon = 1;
 
     if( Ctx.LoRaMacClassBCallbacks.MacProcessNotify != NULL )
@@ -813,7 +848,11 @@ static void LoRaMacClassBProcessBeacon( void )
                 // find a beacon, the state machine will stay in state BEACON_STATE_ACQUISITION.
                 // This state detects that a acquisition was pending previously and will change the next
                 // state to BEACON_STATE_LOST.
-                RxBeaconSetup( 0, true, beaconRxConfig.WindowTimeout );
+                #ifdef REGION_US470
+                     RxBeaconSetup( 0, false, beaconRxConfig.WindowTimeout );
+                #else
+                     RxBeaconSetup( 0, true, beaconRxConfig.WindowTimeout );
+                #endif
             }
             break;
         }
@@ -873,7 +912,9 @@ static void LoRaMacClassBProcessBeacon( void )
                     Ctx.LoRaMacClassBParams.MlmeConfirm->TxTimeOnAir = 0;
                 }
             }
-
+            #ifdef REGION_US470
+               locked_tvws_beacon=1;
+            #endif
             // Setup next state
             Ctx.BeaconState = BEACON_STATE_IDLE;
             break;
@@ -943,6 +984,10 @@ static void LoRaMacClassBProcessBeacon( void )
             InitClassBDefaults( );
 
             Ctx.LoRaMacClassBParams.LoRaMacFlags->Bits.MacDone = 1;
+            #ifdef REGION_US470
+                extern uint8_t beacon_lost;
+                beacon_lost=1;
+            #endif
 
             break;
         }
@@ -957,6 +1002,7 @@ static void LoRaMacClassBProcessBeacon( void )
     {
         TimerSetValue( &Ctx.BeaconTimer, beaconEventTime );
         TimerStart( &Ctx.BeaconTimer );
+      //  printf("BT-ST\r\n");
     }
 }
 #endif // LORAMAC_CLASSB_ENABLED
@@ -1494,7 +1540,10 @@ void LoRaMacClassBHaltBeaconing( void )
 
         // Halt ping slot state machine
         TimerStop( &Ctx.BeaconTimer );
-
+        #ifdef REGION_US470
+          //  printf("B-HLT\r\n");
+            switch_beacon_channel_enabled=1;
+        #endif
         // Halt beacon state machine
         Ctx.BeaconState = BEACON_STATE_HALT;
 
diff --git a/src/mac/LoRaMacCrypto.c b/src/mac/LoRaMacCrypto.c
index cf74c96e..d2df2a06 100644
--- a/src/mac/LoRaMacCrypto.c
+++ b/src/mac/LoRaMacCrypto.c
@@ -1305,7 +1305,7 @@ LoRaMacCryptoStatus_t LoRaMacCryptoSecureMessage( uint32_t fCntUp, uint8_t txDr,
         // Use network session key
         payloadDecryptionKeyID = NWK_S_ENC_KEY;
     }
-
+    
     if( fCntUp > CryptoNvm->FCntList.FCntUp )
     {
         retval = PayloadEncrypt( macMsg->FRMPayload, macMsg->FRMPayloadSize, payloadDecryptionKeyID, macMsg->FHDR.DevAddr, UPLINK, fCntUp );
diff --git a/src/mac/LoRaMacTypes.h b/src/mac/LoRaMacTypes.h
index 1896a376..9d8b60f1 100644
--- a/src/mac/LoRaMacTypes.h
+++ b/src/mac/LoRaMacTypes.h
@@ -73,6 +73,7 @@ extern "C"
  * KR920        | SF12 - BW125
  * US915        | SF10 - BW125
  * RU864        | SF12 - BW125
+ * US470        | SF12 - BW62.5
  */
 #define DR_0                                        0
 
@@ -89,6 +90,7 @@ extern "C"
  * KR920        | SF11 - BW125
  * US915        | SF9  - BW125
  * RU864        | SF11 - BW125
+ * US470        | SF11 - BW62.5
  */
 #define DR_1                                        1
 
@@ -105,6 +107,7 @@ extern "C"
  * KR920        | SF10 - BW125
  * US915        | SF8  - BW125
  * RU864        | SF10 - BW125
+ * US470        | SF10 - BW62.5
  */
 #define DR_2                                        2
 
@@ -121,6 +124,7 @@ extern "C"
  * KR920        | SF9  - BW125
  * US915        | SF7  - BW125
  * RU864        | SF9  - BW125
+ * US470        | SF9 - BW62.5
  */
 #define DR_3                                        3
 
@@ -137,6 +141,7 @@ extern "C"
  * KR920        | SF8  - BW125
  * US915        | SF8  - BW500
  * RU864        | SF8  - BW125
+ * US470        | SF8  - BW62.5
  */
 #define DR_4                                        4
 
@@ -153,6 +158,7 @@ extern "C"
  * KR920        | SF7  - BW125
  * US915        | RFU
  * RU864        | SF7  - BW125
+ * US470        | SF7  - BW62.5
  */
 #define DR_5                                        5
 
@@ -331,6 +337,7 @@ extern "C"
  * KR920        | Max EIRP
  * US915        | Max ERP
  * RU864        | Max EIRP
+ * US470        | Max EIRP
  */
 #define TX_POWER_0                                  0
 
@@ -347,6 +354,7 @@ extern "C"
  * KR920        | Max EIRP - 2
  * US915        | Max ERP - 2
  * RU864        | Max EIRP - 2
+ * US470        | Max EIRP - 2
  */
 #define TX_POWER_1                                  1
 
@@ -363,6 +371,7 @@ extern "C"
  * KR920        | Max EIRP - 4
  * US915        | Max ERP - 4
  * RU864        | Max EIRP - 4
+ * US470        | Max EIRP - 4
  */
 #define TX_POWER_2                                  2
 
@@ -379,6 +388,7 @@ extern "C"
  * KR920        | Max EIRP - 6
  * US915        | Max ERP - 6
  * RU864        | Max EIRP - 6
+ * US470        | Max EIRP - 6
  */
 #define TX_POWER_3                                  3
 
@@ -395,6 +405,7 @@ extern "C"
  * KR920        | Max EIRP - 8
  * US915        | Max ERP - 8
  * RU864        | Max EIRP - 8
+ * US470        | Max EIRP - 8
  */
 #define TX_POWER_4                                  4
 
@@ -411,6 +422,7 @@ extern "C"
  * KR920        | Max EIRP - 10
  * US915        | Max ERP - 10
  * RU864        | Max EIRP - 10
+ * US470        | Max EIRP - 10
  */
 #define TX_POWER_5                                  5
 
@@ -427,6 +439,7 @@ extern "C"
  * KR920        | Max EIRP - 12
  * US915        | Max ERP - 12
  * RU864        | Max EIRP - 12
+ * US470        | Max EIRP - 12
  */
 #define TX_POWER_6                                  6
 
@@ -443,6 +456,7 @@ extern "C"
  * KR920        | Max EIRP - 14
  * US915        | Max ERP - 14
  * RU864        | Max EIRP - 14
+ * US470        | Max EIRP - 14
  */
 #define TX_POWER_7                                  7
 
@@ -459,6 +473,7 @@ extern "C"
  * KR920        | -
  * US915        | Max ERP - 16
  * RU864        | -
+ * US470        | Max ERP - 16
  */
 #define TX_POWER_8                                  8
 
@@ -475,6 +490,7 @@ extern "C"
  * KR920        | -
  * US915        | Max ERP - 18
  * RU864        | -
+ * US470        | Max ERP - 18
  */
 #define TX_POWER_9                                  9
 
@@ -491,6 +507,7 @@ extern "C"
  * KR920        | -
  * US915        | Max ERP - 20
  * RU864        | -
+ * US470        | -
  */
 #define TX_POWER_10                                 10
 
@@ -507,6 +524,7 @@ extern "C"
  * KR920        | -
  * US915        | Max ERP - 22
  * RU864        | -
+ * US470        | -
  */
 #define TX_POWER_11                                 11
 
@@ -523,6 +541,7 @@ extern "C"
  * KR920        | -
  * US915        | Max ERP - 24
  * RU864        | -
+ * US470        | -
  */
 #define TX_POWER_12                                 12
 
@@ -539,6 +558,7 @@ extern "C"
  * KR920        | -
  * US915        | Max ERP - 26
  * RU864        | -
+ * US470        | -
  */
 #define TX_POWER_13                                 13
 
@@ -555,6 +575,7 @@ extern "C"
  * KR920        | -
  * US915        | Max ERP - 28
  * RU864        | -
+ * US470        | -
  */
 #define TX_POWER_14                                 14
 
@@ -1140,6 +1161,9 @@ typedef enum eLoRaMacSrvCmd
      * BeaconFreqReq
      */
     SRV_MAC_BEACON_FREQ_REQ          = 0x13,
+    #ifdef REGION_US470
+        SRV_MAC_WSDB_REQUEST_ANS     = 0x81,
+    #endif
 }LoRaMacSrvCmd_t;
 
 /*!
@@ -1235,6 +1259,25 @@ typedef struct sChannelParams
      * Band index
      */
     uint8_t Band;
+#ifdef REGION_US470
+    TimerTime_t LastChannelUpdateTime;
+    /*!
+     * The last time we have assigned the max
+     * credits for the 24h interval.
+     */
+    TimerTime_t LastChannelMaxCreditAssignTime;
+    /*!
+     * Current time credits which are available. This
+     * is a value in ms
+     */
+    TimerTime_t ChannelTimeCredits;
+    /*!
+     * Maximum time credits which are available. This
+     * is a value in ms
+     */
+    TimerTime_t ChannelMaxTimeCredits;
+
+  #endif
 }ChannelParams_t;
 
 /*!
diff --git a/src/mac/region/Region.c b/src/mac/region/Region.c
index e34dc638..c09e45c5 100644
--- a/src/mac/region/Region.c
+++ b/src/mac/region/Region.c
@@ -472,6 +472,55 @@
 #define US915_RX_BEACON_SETUP( )
 #endif
 
+#ifdef REGION_US470
+#include "RegionUS470.h"
+#define US470_CASE                                 case LORAMAC_REGION_US470:
+#define US470_IS_ACTIVE( )                         US470_CASE { return true; }
+#define US470_GET_PHY_PARAM( )                     US470_CASE { return RegionUS470GetPhyParam( getPhy ); }
+#define US470_SET_BAND_TX_DONE( )                  US470_CASE { RegionUS470SetBandTxDone( txDone ); break; }
+#define US470_INIT_DEFAULTS( )                     US470_CASE { RegionUS470InitDefaults( params ); break; }
+#define US470_VERIFY( )                            US470_CASE { return RegionUS470Verify( verify, phyAttribute ); }
+#define US470_APPLY_CF_LIST( )                     US470_CASE { RegionUS470ApplyCFList( applyCFList ); break; }
+#define US470_CHAN_MASK_SET( )                     US470_CASE { return RegionUS470ChanMaskSet( chanMaskSet ); }
+#define US470_COMPUTE_RX_WINDOW_PARAMETERS( )      US470_CASE { RegionUS470ComputeRxWindowParameters( datarate, minRxSymbols, rxError, rxConfigParams ); break; }
+#define US470_RX_CONFIG( )                         US470_CASE { return RegionUS470RxConfig( rxConfig, datarate ); }
+#define US470_TX_CONFIG( )                         US470_CASE { return RegionUS470TxConfig( txConfig, txPower, txTimeOnAir ); }
+#define US470_LINK_ADR_REQ( )                      US470_CASE { return RegionUS470LinkAdrReq( linkAdrReq, drOut, txPowOut, nbRepOut, nbBytesParsed ); }
+#define US470_RX_PARAM_SETUP_REQ( )                US470_CASE { return RegionUS470RxParamSetupReq( rxParamSetupReq ); }
+#define US470_NEW_CHANNEL_REQ( )                   US470_CASE { return RegionUS470NewChannelReq( newChannelReq ); }
+#define US470_TX_PARAM_SETUP_REQ( )                US470_CASE { return RegionUS470TxParamSetupReq( txParamSetupReq ); }
+#define US470_DL_CHANNEL_REQ( )                    US470_CASE { return RegionUS470DlChannelReq( dlChannelReq ); }
+#define US470_ALTERNATE_DR( )                      US470_CASE { return RegionUS470AlternateDr( currentDr, type ); }
+#define US470_NEXT_CHANNEL( )                      US470_CASE { return RegionUS470NextChannel( nextChanParams, channel, time, aggregatedTimeOff ); }
+#define US470_CHANNEL_ADD( )                       US470_CASE { return RegionUS470ChannelAdd( channelAdd ); }
+#define US470_CHANNEL_REMOVE( )                    US470_CASE { return RegionUS470ChannelsRemove( channelRemove ); }
+#define US470_APPLY_DR_OFFSET( )                   US470_CASE { return RegionUS470ApplyDrOffset( downlinkDwellTime, dr, drOffset ); }
+#define US470_RX_BEACON_SETUP( )                   US470_CASE { RegionUS470RxBeaconSetup( rxBeaconSetup, outDr ); break; }
+#else
+#define US470_IS_ACTIVE( )
+#define US470_GET_PHY_PARAM( )
+#define US470_SET_BAND_TX_DONE( )
+#define US470_INIT_DEFAULTS( )
+#define US470_GET_NVM_CTX( )
+#define US470_VERIFY( )
+#define US470_APPLY_CF_LIST( )
+#define US470_CHAN_MASK_SET( )
+#define US470_COMPUTE_RX_WINDOW_PARAMETERS( )
+#define US470_RX_CONFIG( )
+#define US470_TX_CONFIG( )
+#define US470_LINK_ADR_REQ( )
+#define US470_RX_PARAM_SETUP_REQ( )
+#define US470_NEW_CHANNEL_REQ( )
+#define US470_TX_PARAM_SETUP_REQ( )
+#define US470_DL_CHANNEL_REQ( )
+#define US470_ALTERNATE_DR( )
+#define US470_NEXT_CHANNEL( )
+#define US470_CHANNEL_ADD( )
+#define US470_CHANNEL_REMOVE( )
+#define US470_APPLY_DR_OFFSET( )
+#define US470_RX_BEACON_SETUP( )
+#endif
+
 #ifdef REGION_RU864
 #include "RegionRU864.h"
 #define RU864_CASE                                 case LORAMAC_REGION_RU864:
@@ -535,6 +584,7 @@ bool RegionIsActive( LoRaMacRegion_t region )
         IN865_IS_ACTIVE( );
         US915_IS_ACTIVE( );
         RU864_IS_ACTIVE( );
+        US470_IS_ACTIVE( );
         default:
         {
             return false;
@@ -557,6 +607,7 @@ PhyParam_t RegionGetPhyParam( LoRaMacRegion_t region, GetPhyParams_t* getPhy )
         IN865_GET_PHY_PARAM( );
         US915_GET_PHY_PARAM( );
         RU864_GET_PHY_PARAM( );
+        US470_GET_PHY_PARAM( );
         default:
         {
             return phyParam;
@@ -578,6 +629,7 @@ void RegionSetBandTxDone( LoRaMacRegion_t region, SetBandTxDoneParams_t* txDone
         IN865_SET_BAND_TX_DONE( );
         US915_SET_BAND_TX_DONE( );
         RU864_SET_BAND_TX_DONE( );
+        US470_SET_BAND_TX_DONE( );
         default:
         {
             return;
@@ -599,6 +651,7 @@ void RegionInitDefaults( LoRaMacRegion_t region, InitDefaultsParams_t* params )
         IN865_INIT_DEFAULTS( );
         US915_INIT_DEFAULTS( );
         RU864_INIT_DEFAULTS( );
+        US470_INIT_DEFAULTS( );
         default:
         {
             break;
@@ -620,6 +673,7 @@ bool RegionVerify( LoRaMacRegion_t region, VerifyParams_t* verify, PhyAttribute_
         IN865_VERIFY( );
         US915_VERIFY( );
         RU864_VERIFY( );
+        US470_VERIFY( );
         default:
         {
             return false;
@@ -641,6 +695,7 @@ void RegionApplyCFList( LoRaMacRegion_t region, ApplyCFListParams_t* applyCFList
         IN865_APPLY_CF_LIST( );
         US915_APPLY_CF_LIST( );
         RU864_APPLY_CF_LIST( );
+        US470_APPLY_CF_LIST( );
         default:
         {
             break;
@@ -662,6 +717,7 @@ bool RegionChanMaskSet( LoRaMacRegion_t region, ChanMaskSetParams_t* chanMaskSet
         IN865_CHAN_MASK_SET( );
         US915_CHAN_MASK_SET( );
         RU864_CHAN_MASK_SET( );
+        US470_CHAN_MASK_SET( );
         default:
         {
             return false;
@@ -683,6 +739,7 @@ void RegionComputeRxWindowParameters( LoRaMacRegion_t region, int8_t datarate, u
         IN865_COMPUTE_RX_WINDOW_PARAMETERS( );
         US915_COMPUTE_RX_WINDOW_PARAMETERS( );
         RU864_COMPUTE_RX_WINDOW_PARAMETERS( );
+        US470_COMPUTE_RX_WINDOW_PARAMETERS( );
         default:
         {
             break;
@@ -704,6 +761,7 @@ bool RegionRxConfig( LoRaMacRegion_t region, RxConfigParams_t* rxConfig, int8_t*
         IN865_RX_CONFIG( );
         US915_RX_CONFIG( );
         RU864_RX_CONFIG( );
+        US470_RX_CONFIG( );
         default:
         {
             return false;
@@ -725,6 +783,7 @@ bool RegionTxConfig( LoRaMacRegion_t region, TxConfigParams_t* txConfig, int8_t*
         IN865_TX_CONFIG( );
         US915_TX_CONFIG( );
         RU864_TX_CONFIG( );
+        US470_TX_CONFIG( );
         default:
         {
             return false;
@@ -746,6 +805,7 @@ uint8_t RegionLinkAdrReq( LoRaMacRegion_t region, LinkAdrReqParams_t* linkAdrReq
         IN865_LINK_ADR_REQ( );
         US915_LINK_ADR_REQ( );
         RU864_LINK_ADR_REQ( );
+        US470_LINK_ADR_REQ( );
         default:
         {
             return 0;
@@ -767,6 +827,7 @@ uint8_t RegionRxParamSetupReq( LoRaMacRegion_t region, RxParamSetupReqParams_t*
         IN865_RX_PARAM_SETUP_REQ( );
         US915_RX_PARAM_SETUP_REQ( );
         RU864_RX_PARAM_SETUP_REQ( );
+        US470_RX_PARAM_SETUP_REQ( );
         default:
         {
             return 0;
@@ -788,6 +849,7 @@ int8_t RegionNewChannelReq( LoRaMacRegion_t region, NewChannelReqParams_t* newCh
         IN865_NEW_CHANNEL_REQ( );
         US915_NEW_CHANNEL_REQ( );
         RU864_NEW_CHANNEL_REQ( );
+        US470_NEW_CHANNEL_REQ( );
         default:
         {
             return 0;
@@ -809,6 +871,7 @@ int8_t RegionTxParamSetupReq( LoRaMacRegion_t region, TxParamSetupReqParams_t* t
         IN865_TX_PARAM_SETUP_REQ( );
         US915_TX_PARAM_SETUP_REQ( );
         RU864_TX_PARAM_SETUP_REQ( );
+        US470_TX_PARAM_SETUP_REQ( );
         default:
         {
             return 0;
@@ -830,6 +893,7 @@ int8_t RegionDlChannelReq( LoRaMacRegion_t region, DlChannelReqParams_t* dlChann
         IN865_DL_CHANNEL_REQ( );
         US915_DL_CHANNEL_REQ( );
         RU864_DL_CHANNEL_REQ( );
+        US470_DL_CHANNEL_REQ( );
         default:
         {
             return 0;
@@ -851,14 +915,16 @@ int8_t RegionAlternateDr( LoRaMacRegion_t region, int8_t currentDr, AlternateDrT
         IN865_ALTERNATE_DR( );
         US915_ALTERNATE_DR( );
         RU864_ALTERNATE_DR( );
+        US470_ALTERNATE_DR( );
         default:
         {
             return 0;
         }
     }
 }
-
+ 
 LoRaMacStatus_t RegionNextChannel( LoRaMacRegion_t region, NextChanParams_t* nextChanParams, uint8_t* channel, TimerTime_t* time, TimerTime_t* aggregatedTimeOff )
+ 
 {
     switch( region )
     {
@@ -872,6 +938,7 @@ LoRaMacStatus_t RegionNextChannel( LoRaMacRegion_t region, NextChanParams_t* nex
         IN865_NEXT_CHANNEL( );
         US915_NEXT_CHANNEL( );
         RU864_NEXT_CHANNEL( );
+        US470_NEXT_CHANNEL( );
         default:
         {
             return LORAMAC_STATUS_REGION_NOT_SUPPORTED;
@@ -893,6 +960,7 @@ LoRaMacStatus_t RegionChannelAdd( LoRaMacRegion_t region, ChannelAddParams_t* ch
         IN865_CHANNEL_ADD( );
         US915_CHANNEL_ADD( );
         RU864_CHANNEL_ADD( );
+        US470_CHANNEL_ADD( );
         default:
         {
             return LORAMAC_STATUS_PARAMETER_INVALID;
@@ -914,6 +982,7 @@ bool RegionChannelsRemove( LoRaMacRegion_t region, ChannelRemoveParams_t* channe
         IN865_CHANNEL_REMOVE( );
         US915_CHANNEL_REMOVE( );
         RU864_CHANNEL_REMOVE( );
+        US470_CHANNEL_REMOVE( );
         default:
         {
             return false;
@@ -935,6 +1004,7 @@ uint8_t RegionApplyDrOffset( LoRaMacRegion_t region, uint8_t downlinkDwellTime,
         IN865_APPLY_DR_OFFSET( );
         US915_APPLY_DR_OFFSET( );
         RU864_APPLY_DR_OFFSET( );
+        US470_APPLY_DR_OFFSET( );
         default:
         {
             return dr;
@@ -956,6 +1026,7 @@ void RegionRxBeaconSetup( LoRaMacRegion_t region, RxBeaconSetup_t* rxBeaconSetup
         IN865_RX_BEACON_SETUP( );
         US915_RX_BEACON_SETUP( );
         RU864_RX_BEACON_SETUP( );
+        US470_RX_BEACON_SETUP( );
         default:
         {
             break;
diff --git a/src/mac/region/Region.h b/src/mac/region/Region.h
index b6ba4bb9..d0a756fa 100644
--- a/src/mac/region/Region.h
+++ b/src/mac/region/Region.h
@@ -72,9 +72,9 @@ extern "C"
 #ifndef REGION_VERSION
 /*!
  * Regional parameters version definition.
- * RP002-1.0.3
+ * RP002-1.0.1
  */
-#define REGION_VERSION                              0x02010003
+#define REGION_VERSION                              0x02010001
 #endif
 
 
@@ -437,7 +437,10 @@ typedef struct sGetPhyParams
      * The parameter is needed for the following queries:
      * PHY_BEACON_CHANNEL_FREQ, PHY_PING_SLOT_CHANNEL_FREQ
      */
+   
     uint8_t Channel;
+  
+
 }GetPhyParams_t;
 
 /*!
@@ -448,7 +451,9 @@ typedef struct sSetBandTxDoneParams
     /*!
      * Channel to update.
      */
+   
     uint8_t Channel;
+  
     /*!
      * Joined Set to true, if the node has joined the network
      */
@@ -620,7 +625,9 @@ typedef struct sTxConfigParams
     /*!
      * The TX channel.
      */
+ 
     uint8_t Channel;
+  
     /*!
      * The TX datarate.
      */
@@ -743,7 +750,9 @@ typedef struct sDlChannelReqParams
     /*!
      * Channel Id to add the frequency.
      */
+ 
     uint8_t ChannelId;
+ 
     /*!
      * Alternative frequency for the Rx1 window.
      */
@@ -816,7 +825,9 @@ typedef struct sChannelAddParams
     /*!
      * Channel id to add.
      */
-    uint8_t ChannelId;
+ 
+    uint8_t  ChannelId;
+ 
 }ChannelAddParams_t;
 
 /*!
@@ -827,7 +838,9 @@ typedef struct sChannelRemoveParams
     /*!
      * Channel id to remove.
      */
+ 
     uint8_t ChannelId;
+ 
 }ChannelRemoveParams_t;
 
 /*!
@@ -1099,7 +1112,9 @@ int8_t RegionAlternateDr( LoRaMacRegion_t region, int8_t currentDr, AlternateDrT
  *
  * \retval Function status [1: OK, 0: Unable to find a channel on the current datarate].
  */
+ 
 LoRaMacStatus_t RegionNextChannel( LoRaMacRegion_t region, NextChanParams_t* nextChanParams, uint8_t* channel, TimerTime_t* time, TimerTime_t* aggregatedTimeOff );
+ 
 
 /*!
  * \brief Adds a channel.
diff --git a/src/mac/region/RegionBaseUS.c b/src/mac/region/RegionBaseUS.c
index 2eacb698..645f7cc9 100644
--- a/src/mac/region/RegionBaseUS.c
+++ b/src/mac/region/RegionBaseUS.c
@@ -34,7 +34,7 @@
 #include "region/Region.h"
 #include "RegionBaseUS.h"
 
-
+#include<stdio.h>
 /*!
  * \brief Searches for available 125 kHz channels in the given channel mask.
  *
@@ -46,6 +46,35 @@
  *
  * \retval Status
  */
+#ifdef REGION_US470
+
+static LoRaMacStatus_t FindAvailable125kHzChannels( uint64_t currentChannelMaskLeft,
+                                                    uint8_t* findAvailableChannelsIndex, uint8_t* availableChannels )
+{
+    // Nullpointer check
+    if( findAvailableChannelsIndex == NULL || availableChannels == NULL )
+    {
+        return LORAMAC_STATUS_PARAMETER_INVALID;
+    }
+
+    // Initialize counter
+    *availableChannels = 0;
+    for( uint8_t i = 0; i < 44; i++ )
+    {
+        // Find available channels
+        uint64_t mask=( 1 << i );
+        if( ( currentChannelMaskLeft & mask ) != 0 )
+        {
+            // Save available channel index
+            findAvailableChannelsIndex[*availableChannels] = i;
+            // Increment counter of available channels if the current channel is available
+            ( *availableChannels )++;
+        }
+    }
+
+    return LORAMAC_STATUS_OK;
+}
+#else
 static LoRaMacStatus_t FindAvailable125kHzChannels( uint16_t currentChannelMaskLeft,
                                                     uint8_t* findAvailableChannelsIndex, uint8_t* availableChannels )
 {
@@ -71,15 +100,19 @@ static LoRaMacStatus_t FindAvailable125kHzChannels( uint16_t currentChannelMaskL
 
     return LORAMAC_STATUS_OK;
 }
+#endif
 
+ 
 LoRaMacStatus_t RegionBaseUSComputeNext125kHzJoinChannel( uint16_t* channelsMaskRemaining,
                                                           uint8_t* groupsCurrentIndex, uint8_t* newChannelIndex )
 {
     uint8_t currentChannelMaskLeftIndex;
-    uint16_t currentChannelMaskLeft;
+    uint8_t currentChannelMaskLeft;
+
     uint8_t findAvailableChannelsIndex[8] = { 0 };
-    uint8_t availableChannels = 0;
-    uint8_t startIndex;
+ 
+      uint8_t availableChannels = 0;
+      uint8_t startIndex;
 
     // Null pointer check
     if( channelsMaskRemaining == NULL || groupsCurrentIndex == NULL || newChannelIndex == NULL )
@@ -92,9 +125,10 @@ LoRaMacStatus_t RegionBaseUSComputeNext125kHzJoinChannel( uint16_t* channelsMask
 
     do
     {
+ 
         // Current ChannelMaskRemaining, two groups per channel mask. For example Group 0 and 1 (8 bit) are ChannelMaskRemaining 0 (16 bit), etc.
-        currentChannelMaskLeftIndex = (uint8_t) startIndex / 2;
-
+      currentChannelMaskLeftIndex = (uint32_t) startIndex / 2;
+      
         // For even numbers we need the 8 LSBs and for uneven the 8 MSBs
         if( ( startIndex % 2 ) == 0 )
         {
@@ -104,30 +138,40 @@ LoRaMacStatus_t RegionBaseUSComputeNext125kHzJoinChannel( uint16_t* channelsMask
         {
             currentChannelMaskLeft = ( ( channelsMaskRemaining[currentChannelMaskLeftIndex] >> 8 ) & 0x00FF );
         }
-
-
+ 
+      
         if( FindAvailable125kHzChannels( currentChannelMaskLeft, findAvailableChannelsIndex, &availableChannels ) == LORAMAC_STATUS_PARAMETER_INVALID )
         {
             return LORAMAC_STATUS_PARAMETER_INVALID;
         }
-
+        
         if ( availableChannels > 0 )
         {
+        #ifdef REGION_US470
+           
             // Choose randomly a free channel 125kHz
-            *newChannelIndex = ( startIndex * 8 ) + findAvailableChannelsIndex[randr( 0, ( availableChannels - 1 ) )];
+          *newChannelIndex = ( startIndex * 8 ) + findAvailableChannelsIndex[randr( 0, ( availableChannels - 1 ) )];
+      
+      
+        #else
+            *newChannelIndex = ( startIndex * 44 ) + findAvailableChannelsIndex[randr( 0, ( availableChannels - 1 ) )];
+        #endif
         }
 
+        
         // Increment start index
         startIndex++;
-        if ( startIndex > 7 )
-        {
-            startIndex = 0;
-        }
+         if(startIndex >11) // to avoid channel > 88
+            {
+                startIndex=0;
+            }
     } while( ( availableChannels == 0 ) && ( startIndex != *groupsCurrentIndex ) );
 
+    
     if ( availableChannels > 0 )
     {
         *groupsCurrentIndex = startIndex;
+       
         return LORAMAC_STATUS_OK;
     }
 
@@ -145,7 +189,8 @@ bool RegionBaseUSVerifyFrequencyGroup( uint32_t freq, uint32_t minFreq, uint32_t
     return true;
 }
 
-uint32_t RegionBaseUSCalcDownlinkFrequency( uint8_t channel, uint32_t frequency,
+ 
+ uint32_t RegionBaseUSCalcDownlinkFrequency( uint8_t channel, uint32_t frequency,
                                             uint32_t stepwidth )
 {
     // Calculate the frequency
diff --git a/src/mac/region/RegionBaseUS.h b/src/mac/region/RegionBaseUS.h
index 72edfb5b..02f0c5ba 100644
--- a/src/mac/region/RegionBaseUS.h
+++ b/src/mac/region/RegionBaseUS.h
@@ -55,8 +55,10 @@ extern "C"
  *
  * \retval Status
  */
+ 
 LoRaMacStatus_t RegionBaseUSComputeNext125kHzJoinChannel( uint16_t* channelsMaskRemaining,
                                                           uint8_t* groupsCurrentIndex, uint8_t* newChannelIndex );
+ 
 
 /*!
  * \brief Verifies if the frequency is in the correct range with a
@@ -86,9 +88,10 @@ bool RegionBaseUSVerifyFrequencyGroup( uint32_t freq, uint32_t minFreq, uint32_t
  *
  * \retval The downlink frequency.
  */
+ 
 uint32_t RegionBaseUSCalcDownlinkFrequency( uint8_t channel, uint32_t frequency,
                                             uint32_t stepwidth );
-
+ 
 /*! \} defgroup REGIONBASEUS */
 
 #ifdef __cplusplus
diff --git a/src/mac/region/RegionCommon.c b/src/mac/region/RegionCommon.c
index 36c3242a..f3858d81 100644
--- a/src/mac/region/RegionCommon.c
+++ b/src/mac/region/RegionCommon.c
@@ -215,15 +215,16 @@ static uint8_t CountChannels( uint16_t mask, uint8_t nbBits )
     }
     return nbActiveBits;
 }
-
+ 
 bool RegionCommonChanVerifyDr( uint8_t nbChannels, uint16_t* channelsMask, int8_t dr, int8_t minDr, int8_t maxDr, ChannelParams_t* channels )
+ 
 {
     if( RegionCommonValueInRange( dr, minDr, maxDr ) == 0 )
     {
         return false;
     }
-
-    for( uint8_t i = 0, k = 0; i < nbChannels; i += 16, k++ )
+ 
+ for( uint8_t i = 0, k = 0; i < nbChannels; i += 16, k++ )
     {
         for( uint8_t j = 0; j < 16; j++ )
         {
@@ -249,11 +250,12 @@ uint8_t RegionCommonValueInRange( int8_t value, int8_t min, int8_t max )
     }
     return 0;
 }
-
+ 
+ 
 bool RegionCommonChanDisable( uint16_t* channelsMask, uint8_t id, uint8_t maxChannels )
 {
     uint8_t index = id / 16;
-
+ 
     if( ( index > ( maxChannels / 16 ) ) || ( id >= maxChannels ) )
     {
         return false;
@@ -264,11 +266,12 @@ bool RegionCommonChanDisable( uint16_t* channelsMask, uint8_t id, uint8_t maxCha
 
     return true;
 }
-
+ 
+ 
 uint8_t RegionCommonCountChannels( uint16_t* channelsMask, uint8_t startIdx, uint8_t stopIdx )
 {
     uint8_t nbChannels = 0;
-
+ 
     if( channelsMask == NULL )
     {
         return 0;
@@ -309,6 +312,7 @@ void RegionCommonSetBandTxDone( Band_t* band, TimerTime_t lastTxAirTime, bool jo
     {
         band->TimeCredits = 0;
     }
+ //   printf("BTC %d TC %d LTA %d\r\n", band->TimeCredits,dutyCycle, lastTxAirTime);
 }
 
 TimerTime_t RegionCommonUpdateBandTimeOff( bool joined, Band_t* bands,
@@ -332,7 +336,7 @@ TimerTime_t RegionCommonUpdateBandTimeOff( bool joined, Band_t* bands,
         // Calculate the credit costs for the next transmission
         // with the duty cycle and the expected time on air
         creditCosts = expectedTimeOnAir * dutyCycle;
-
+        //printf("Creditcost %d  tc %d\r\n",creditCosts, bands[i].TimeCredits);
         // Check if the band is ready for transmission. Its ready,
         // when the duty cycle is off, or the TimeCredits of the band
         // is higher than the credit costs for the transmission.
@@ -549,18 +553,25 @@ void RegionCommonRxBeaconSetup( RegionCommonRxBeaconSetupParams_t* rxBeaconSetup
 
     Radio.Rx( rxBeaconSetupParams->RxTime );
 }
-
+ 
 void RegionCommonCountNbOfEnabledChannels( RegionCommonCountNbOfEnabledChannelsParams_t* countNbOfEnabledChannelsParams,
                                            uint8_t* enabledChannels, uint8_t* nbEnabledChannels, uint8_t* nbRestrictedChannels )
+       
+ 
 {
-    uint8_t nbChannelCount = 0;
+    
+ 
+uint8_t nbChannelCount = 0;
     uint8_t nbRestrictedChannelsCount = 0;
-
-    for( uint8_t i = 0, k = 0; i < countNbOfEnabledChannelsParams->MaxNbChannels; i += 16, k++ )
+  for( uint8_t i = 0, k = 0; i < countNbOfEnabledChannelsParams->MaxNbChannels; i += 16, k++ )
+ 
     {
         for( uint8_t j = 0; j < 16; j++ )
         {
-            if( ( countNbOfEnabledChannelsParams->ChannelsMask[k] & ( 1 << j ) ) != 0 )
+       
+
+          if( ( countNbOfEnabledChannelsParams->ChannelsMask[k] & ( 1 << j ) ) != 0 )
+    
             {
                 if( countNbOfEnabledChannelsParams->Channels[i + j].Frequency == 0 )
                 { // Check if the channel is enabled
@@ -569,7 +580,9 @@ void RegionCommonCountNbOfEnabledChannels( RegionCommonCountNbOfEnabledChannelsP
                 if( ( countNbOfEnabledChannelsParams->Joined == false ) &&
                     ( countNbOfEnabledChannelsParams->JoinChannels != NULL ) )
                 {
+                   
                     if( ( countNbOfEnabledChannelsParams->JoinChannels[k] & ( 1 << j ) ) == 0 )
+                 //df   if( ( countNbOfEnabledChannelsParams->JoinChannels[k] & bit_pattern[j] ) == 0 )
                     {
                         continue;
                     }
@@ -587,17 +600,22 @@ void RegionCommonCountNbOfEnabledChannels( RegionCommonCountNbOfEnabledChannelsP
                 }
                 enabledChannels[nbChannelCount++] = i + j;
             }
+             
         }
+       
     }
+    
     *nbEnabledChannels = nbChannelCount;
     *nbRestrictedChannels = nbRestrictedChannelsCount;
 }
-
-LoRaMacStatus_t RegionCommonIdentifyChannels( RegionCommonIdentifyChannelsParam_t* identifyChannelsParam,
+ 
+ 
+LoRaMacStatus_t RegionCommonIdentifyChannels(  RegionCommonIdentifyChannelsParam_t* identifyChannelsParam,
                                               TimerTime_t* aggregatedTimeOff, uint8_t* enabledChannels,
                                               uint8_t* nbEnabledChannels, uint8_t* nbRestrictedChannels,
                                               TimerTime_t* nextTxDelay )
-{
+ 
+ {
     TimerTime_t elapsed = TimerGetElapsedTime( identifyChannelsParam->LastAggrTx );
     *nextTxDelay = identifyChannelsParam->AggrTimeOff - elapsed;
     *nbRestrictedChannels = 1;
@@ -637,6 +655,54 @@ LoRaMacStatus_t RegionCommonIdentifyChannels( RegionCommonIdentifyChannelsParam_
     }
 }
 
+#ifdef REGION_US470
+LoRaMacStatus_t RegionCommonChannelIdentifyChannels( ChannelParams_t *currentchannelParam , RegionCommonIdentifyChannelsParam_t* identifyChannelsParam,
+                                              TimerTime_t* aggregatedTimeOff, uint8_t* enabledChannels,
+                                              uint8_t* nbEnabledChannels, uint8_t* nbRestrictedChannels,
+                                              TimerTime_t* nextTxDelay )
+ {
+    TimerTime_t elapsed = TimerGetElapsedTime( identifyChannelsParam->LastAggrTx );
+    *nextTxDelay = identifyChannelsParam->AggrTimeOff - elapsed;
+    *nbRestrictedChannels = 1;
+    *nbEnabledChannels = 0;
+
+    if( ( identifyChannelsParam->LastAggrTx == 0 ) ||
+        ( identifyChannelsParam->AggrTimeOff <= elapsed ) )
+    {
+        // Reset Aggregated time off
+        *aggregatedTimeOff = 0;
+
+     *nextTxDelay = RegionCommonUpdateChannelTimeOff( currentchannelParam,identifyChannelsParam->CountNbOfEnabledChannelsParam->Joined,
+                                                      identifyChannelsParam->CountNbOfEnabledChannelsParam->Bands,
+                                                      identifyChannelsParam->MaxBands,
+                                                      identifyChannelsParam->DutyCycleEnabled,
+                                                      identifyChannelsParam->LastTxIsJoinRequest,
+                                                      identifyChannelsParam->ElapsedTimeSinceStartUp,
+                                                      identifyChannelsParam->ExpectedTimeOnAir );
+
+     
+ 
+    
+        RegionCommonCountNbOfEnabledChannels( identifyChannelsParam->CountNbOfEnabledChannelsParam, enabledChannels,
+                                              nbEnabledChannels, nbRestrictedChannels );
+    }
+
+    if( *nbEnabledChannels > 0 )
+    {
+        *nextTxDelay = 0;
+        return LORAMAC_STATUS_OK;
+    }
+    else if( *nbRestrictedChannels > 0 )
+    {
+        return LORAMAC_STATUS_DUTYCYCLE_RESTRICTED;
+    }
+    else
+    {
+        return LORAMAC_STATUS_NO_CHANNEL_FOUND;
+    }
+}
+#endif
+
 int8_t RegionCommonGetNextLowerTxDr( RegionCommonGetNextLowerTxDrParams_t *params )
 {
     int8_t drLocal = params->CurrentDr;
@@ -676,3 +742,252 @@ uint32_t RegionCommonGetBandwidth( uint32_t drIndex, const uint32_t* bandwidths
             return 2;
     }
 }
+
+#ifdef REGION_US470
+static uint16_t GetChannelDutyCycle( Band_t* band, bool joined, SysTime_t elapsedTimeSinceStartup )
+{
+    uint16_t dutyCycle = band->DCycle;
+
+    if( joined == false )
+    {
+        uint16_t joinDutyCycle = BACKOFF_DC_24_HOURS;
+
+        if( elapsedTimeSinceStartup.Seconds < BACKOFF_DUTY_CYCLE_1_HOUR_IN_S )
+        {
+            joinDutyCycle = BACKOFF_DC_1_HOUR;
+        }
+        else if( elapsedTimeSinceStartup.Seconds < BACKOFF_DUTY_CYCLE_10_HOURS_IN_S )
+        {
+            joinDutyCycle = BACKOFF_DC_10_HOURS;
+        }
+        else
+        {
+            joinDutyCycle = BACKOFF_DC_24_HOURS;
+        }
+        // Take the most restrictive duty cycle
+        dutyCycle = MAX( dutyCycle, joinDutyCycle );
+    }
+
+    // Prevent value of 0
+    if( dutyCycle == 0 )
+    {
+        dutyCycle = 1;
+    }
+
+    return dutyCycle;
+}
+
+
+
+static uint16_t SetChannelMaxTimeCredits(ChannelParams_t *currentchannelParam , Band_t* band, bool joined, SysTime_t elapsedTimeSinceStartup,
+                                   bool dutyCycleEnabled, bool lastTxIsJoinRequest )
+{
+    uint16_t dutyCycle = band->DCycle;
+    TimerTime_t maxCredits = DUTY_CYCLE_TIME_PERIOD;
+    TimerTime_t elapsedTime = SysTimeToMs( elapsedTimeSinceStartup );
+    SysTime_t timeDiff = { 0 };
+
+    // Get the band duty cycle. If not joined, the function either returns the join duty cycle
+    // or the band duty cycle, whichever is more restrictive.
+    dutyCycle = GetChannelDutyCycle( band, joined, elapsedTimeSinceStartup );
+    if( joined == false )
+    {
+        if( dutyCycle == BACKOFF_DC_1_HOUR )
+        {
+            maxCredits = DUTY_CYCLE_TIME_PERIOD;
+            currentchannelParam->LastChannelMaxCreditAssignTime = elapsedTime;
+        }
+        else if( dutyCycle == BACKOFF_DC_10_HOURS )
+        {
+            maxCredits = DUTY_CYCLE_TIME_PERIOD * 10;
+             currentchannelParam->LastChannelMaxCreditAssignTime = elapsedTime;
+        }
+        else
+        {
+            maxCredits = DUTY_CYCLE_TIME_PERIOD * 24;
+        }
+
+        timeDiff = SysTimeSub( elapsedTimeSinceStartup, SysTimeFromMs(  currentchannelParam->LastChannelMaxCreditAssignTime ) );
+
+        // Verify if we have to assign the maximum credits in cases
+        // of the preconditions have changed.
+        if( ( ( dutyCycleEnabled == false ) && ( lastTxIsJoinRequest == false ) ) ||
+            ( currentchannelParam->ChannelMaxTimeCredits != maxCredits ) ||
+            ( timeDiff.Seconds >= BACKOFF_24_HOURS_IN_S ) )
+        {
+            currentchannelParam->ChannelTimeCredits = maxCredits;
+
+            if( elapsedTimeSinceStartup.Seconds >= BACKOFF_DUTY_CYCLE_24_HOURS_IN_S )
+            {
+                timeDiff.Seconds = ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S;
+                timeDiff.Seconds *= BACKOFF_24_HOURS_IN_S;
+                timeDiff.Seconds += BACKOFF_DUTY_CYCLE_24_HOURS_IN_S;
+                timeDiff.SubSeconds = 0;
+                currentchannelParam->LastChannelMaxCreditAssignTime = SysTimeToMs( timeDiff );
+            }
+        }
+    }
+    else
+    {
+        if( dutyCycleEnabled == false )
+        {
+            // Assign max credits when the duty cycle is disabled.
+            currentchannelParam->ChannelTimeCredits = maxCredits;
+        }
+    }
+
+    // Assign the max credits if its the first time
+    if( currentchannelParam->LastChannelUpdateTime == 0 )
+    {
+        currentchannelParam->ChannelMaxTimeCredits = maxCredits;
+    }
+
+    // Setup the maximum allowed credits. We can assign them
+    // safely all the time.
+   currentchannelParam->ChannelMaxTimeCredits = maxCredits;
+
+    return dutyCycle;
+}
+
+ 
+
+static uint16_t UpdateChannelTimeCredits(ChannelParams_t *currentchannelParam ,  Band_t* band, bool joined, bool dutyCycleEnabled,
+                                   bool lastTxIsJoinRequest, SysTime_t elapsedTimeSinceStartup,
+                                   TimerTime_t currentTime )
+{
+    uint16_t dutyCycle = SetChannelMaxTimeCredits( currentchannelParam,band, joined, elapsedTimeSinceStartup,
+                                            dutyCycleEnabled, lastTxIsJoinRequest );
+
+    if( joined == true )
+    {
+        // Apply a sliding window for the duty cycle with collection and speding
+        // credits.
+        currentchannelParam->ChannelTimeCredits += TimerGetElapsedTime( currentchannelParam->LastChannelUpdateTime );
+    }
+
+    // Limit band credits to maximum
+    if( currentchannelParam->ChannelTimeCredits > currentchannelParam->ChannelMaxTimeCredits )
+    {
+       currentchannelParam->ChannelTimeCredits = currentchannelParam->ChannelMaxTimeCredits;
+    }
+
+    // Synchronize update time
+    currentchannelParam->LastChannelUpdateTime = currentTime;
+
+    return dutyCycle;
+}
+
+void RegionCommonSetChannelTxDone(ChannelParams_t *currentchannelParam ,  Band_t* band, TimerTime_t lastTxAirTime, bool joined, SysTime_t elapsedTimeSinceStartup )
+{
+    // Get the band duty cycle. If not joined, the function either returns the join duty cycle
+    // or the band duty cycle, whichever is more restrictive.
+    uint16_t dutyCycle = GetChannelDutyCycle( band, joined, elapsedTimeSinceStartup );
+
+    // Reduce with transmission time
+    if( currentchannelParam->ChannelTimeCredits > ( lastTxAirTime * dutyCycle ) )
+    {
+        // Reduce time credits by the time of air
+       currentchannelParam->ChannelTimeCredits -= ( lastTxAirTime * dutyCycle );
+    }
+    else
+    {
+        currentchannelParam->ChannelTimeCredits  = 0;
+    }
+   
+}
+
+TimerTime_t RegionCommonUpdateChannelTimeOff(ChannelParams_t *currentchannelParam ,  bool joined, Band_t* bands,
+                                           uint8_t nbBands, bool dutyCycleEnabled,
+                                           bool lastTxIsJoinRequest, SysTime_t elapsedTimeSinceStartup,
+                                           TimerTime_t expectedTimeOnAir )
+{
+    TimerTime_t minTimeToWait = TIMERTIME_T_MAX;
+    TimerTime_t currentTime = TimerGetCurrentTime( );
+    TimerTime_t creditCosts = 0;
+    uint16_t dutyCycle = 1;
+    uint8_t validBands = 0;
+
+ //   for( uint8_t i = 0; i < nbBands; i++ )
+    {
+        // Synchronization of channels and credits
+        dutyCycle = UpdateChannelTimeCredits(currentchannelParam, &bands[0], joined, dutyCycleEnabled,
+                                       lastTxIsJoinRequest, elapsedTimeSinceStartup,
+                                       currentTime );
+
+        // Calculate the credit costs for the next transmission
+        // with the duty cycle and the expected time on air
+        creditCosts = expectedTimeOnAir * dutyCycle;
+
+        // Check if the band is ready for transmission. Its ready,
+        // when the duty cycle is off, or the TimeCredits of the band
+        // is higher than the credit costs for the transmission.
+        if( ( currentchannelParam->ChannelTimeCredits > creditCosts ) ||
+            ( ( dutyCycleEnabled == false ) && ( joined == true ) ) )
+        {
+            bands[0].ReadyForTransmission = true;
+            // This band is a potential candidate for an
+            // upcoming transmission, so increase the counter.
+            validBands++;
+        }
+        else
+        {
+            // In this case, the band has not enough credits
+            // for the next transmission.
+            bands[0].ReadyForTransmission = false;
+
+            if(currentchannelParam->ChannelMaxTimeCredits > creditCosts )
+            {
+                // The band can only be taken into account, if the maximum credits
+                // of the band are higher than the credit costs.
+                // We calculate the minTimeToWait among the bands which are not
+                // ready for transmission and which are potentially available
+                // for a transmission in the future.
+                minTimeToWait = MIN( minTimeToWait, ( creditCosts - currentchannelParam->ChannelTimeCredits  ) );
+                // This band is a potential candidate for an
+                // upcoming transmission (even if its time credits are not enough
+                // at the moment), so increase the counter.
+                validBands++;
+            }
+
+            // Apply a special calculation if the device is not joined.
+            if( joined == false )
+            {
+                SysTime_t backoffTimeRange = {
+                    .Seconds    = 0,
+                    .SubSeconds = 0,
+                };
+                // Get the backoff time range based on the duty cycle definition
+                if( dutyCycle == BACKOFF_DC_1_HOUR )
+                {
+                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_1_HOUR_IN_S;
+                }
+                else if( dutyCycle == BACKOFF_DC_10_HOURS )
+                {
+                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_10_HOURS_IN_S;
+                }
+                else
+                {
+                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_24_HOURS_IN_S;
+                }
+                // Calculate the time to wait.
+                if( elapsedTimeSinceStartup.Seconds > BACKOFF_DUTY_CYCLE_24_HOURS_IN_S )
+                {
+                    backoffTimeRange.Seconds += BACKOFF_24_HOURS_IN_S * ( ( ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S ) + 1 );
+                }
+                // Calculate the time difference between now and the next range
+                backoffTimeRange  = SysTimeSub( backoffTimeRange, elapsedTimeSinceStartup );
+                minTimeToWait = SysTimeToMs( backoffTimeRange );
+            }
+        }
+    }
+
+
+    if( validBands == 0 )
+    {
+        // There is no valid band available to handle a transmission
+        // in the given DUTY_CYCLE_TIME_PERIOD.
+        return TIMERTIME_T_MAX;
+    }
+    return minTimeToWait;
+}
+#endif
diff --git a/src/mac/region/RegionCommon.h b/src/mac/region/RegionCommon.h
index ffb663be..f83fa53c 100644
--- a/src/mac/region/RegionCommon.h
+++ b/src/mac/region/RegionCommon.h
@@ -369,8 +369,10 @@ uint8_t RegionCommonValueInRange( int8_t value, int8_t min, int8_t max );
  *
  * \retval Returns true if the datarate is supported, false if not.
  */
+ 
 bool RegionCommonChanVerifyDr( uint8_t nbChannels, uint16_t* channelsMask, int8_t dr,
                             int8_t minDr, int8_t maxDr, ChannelParams_t* channels );
+ 
 
 /*!
  * \brief Disables a channel in a given channels mask.
@@ -384,7 +386,9 @@ bool RegionCommonChanVerifyDr( uint8_t nbChannels, uint16_t* channelsMask, int8_
  *
  * \retval Returns true if the channel could be disabled, false if not.
  */
+ 
 bool RegionCommonChanDisable( uint16_t* channelsMask, uint8_t id, uint8_t maxChannels );
+ 
 
 /*!
  * \brief Counts the number of active channels in a given channels mask.
@@ -398,7 +402,10 @@ bool RegionCommonChanDisable( uint16_t* channelsMask, uint8_t id, uint8_t maxCha
  *
  * \retval Returns the number of active channels.
  */
+
+ 
 uint8_t RegionCommonCountChannels( uint16_t* channelsMask, uint8_t startIdx, uint8_t stopIdx );
+ 
 
 /*!
  * \brief Copy a channels mask.
@@ -556,9 +563,12 @@ void RegionCommonRxBeaconSetup( RegionCommonRxBeaconSetupParams_t* rxBeaconSetup
  * \param [OUT] nbRestrictedChannels It contains the number of channel
  *                      which are available, but restricted due to duty cycle.
  */
+ 
 void RegionCommonCountNbOfEnabledChannels( RegionCommonCountNbOfEnabledChannelsParams_t* countNbOfEnabledChannelsParams,
                                            uint8_t* enabledChannels, uint8_t* nbEnabledChannels, uint8_t* nbRestrictedChannels );
 
+ 
+
 /*!
  * \brief Identifies all channels which are available currently.
  *
@@ -580,11 +590,12 @@ void RegionCommonCountNbOfEnabledChannels( RegionCommonCountNbOfEnabledChannelsP
  *
  *\retval Status of the operation.
  */
+ 
 LoRaMacStatus_t RegionCommonIdentifyChannels( RegionCommonIdentifyChannelsParam_t* identifyChannelsParam,
                                               TimerTime_t* aggregatedTimeOff, uint8_t* enabledChannels,
                                               uint8_t* nbEnabledChannels, uint8_t* nbRestrictedChannels,
                                               TimerTime_t* nextTxDelay );
-
+ 
 /*!
  * \brief Selects the next lower datarate.
  *
@@ -618,6 +629,20 @@ uint32_t RegionCommonGetBandwidth( uint32_t drIndex, const uint32_t* bandwidths
 
 /*! \} defgroup REGIONCOMMON */
 
+#ifdef REGION_US470
+TimerTime_t RegionCommonUpdateChannelTimeOff(ChannelParams_t *currentchannelParam ,  bool joined, Band_t* bands,
+                                           uint8_t nbBands, bool dutyCycleEnabled,
+                                           bool lastTxIsJoinRequest, SysTime_t elapsedTimeSinceStartup,
+                                           TimerTime_t expectedTimeOnAir );
+
+
+LoRaMacStatus_t RegionCommonChannelIdentifyChannels( ChannelParams_t *currentchannelParam , RegionCommonIdentifyChannelsParam_t* identifyChannelsParam,
+                                              TimerTime_t* aggregatedTimeOff, uint8_t* enabledChannels,
+                                              uint8_t* nbEnabledChannels, uint8_t* nbRestrictedChannels,
+                                              TimerTime_t* nextTxDelay );
+void RegionCommonSetChannelTxDone(ChannelParams_t *currentchannelParam ,  Band_t* band, TimerTime_t lastTxAirTime, bool joined, SysTime_t elapsedTimeSinceStartup );
+
+#endif
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/mac/region/RegionKR920.c b/src/mac/region/RegionKR920.c
index d09283a5..7e00924a 100644
--- a/src/mac/region/RegionKR920.c
+++ b/src/mac/region/RegionKR920.c
@@ -321,6 +321,7 @@ void RegionKR920InitDefaults( InitDefaultsParams_t* params )
             memcpy1( ( uint8_t* )RegionBands, ( uint8_t* )bands, sizeof( Band_t ) * KR920_MAX_NB_BANDS );
 
             // Default channels
+            
             RegionNvmGroup2->Channels[0] = ( ChannelParams_t ) KR920_LC1;
             RegionNvmGroup2->Channels[1] = ( ChannelParams_t ) KR920_LC2;
             RegionNvmGroup2->Channels[2] = ( ChannelParams_t ) KR920_LC3;
diff --git a/src/mac/region/RegionNvm.h b/src/mac/region/RegionNvm.h
index 5018df61..48dd0400 100644
--- a/src/mac/region/RegionNvm.h
+++ b/src/mac/region/RegionNvm.h
@@ -55,6 +55,10 @@ typedef enum eRegionCN470ChannelPlan
 // Selection of REGION_NVM_MAX_NB_CHANNELS
 #if defined( REGION_CN470 )
     #define REGION_NVM_MAX_NB_CHANNELS                 96
+#elif defined(REGION_US470)
+ //dynamically selected out of 968 channels RFChannelA(44) + RFchannel(44)
+    #define REGION_NVM_MAX_NB_CHANNELS                  88 
+    #define REGION_NVM_MAX_RFCHAIN_CHANNELS             44 
 #elif defined( REGION_US915 ) || defined( REGION_AU915 )
     #define REGION_NVM_MAX_NB_CHANNELS                 72
 #else
@@ -74,6 +78,17 @@ typedef enum eRegionCN470ChannelPlan
 #if defined( REGION_CN470 ) || defined( REGION_US915 ) || \
     defined( REGION_AU915 )
     #define REGION_NVM_CHANNELS_MASK_SIZE              6
+#elif defined (REGION_US470) 
+// 44 dynamic RF Channel 8
+// bytes(0,1) FFFF -> 0 to 15 channels
+//bytes(2,3) FFFF -> 16 - 31 channels
+// bytes (4,5) 03FF > 32 - 44 channels
+
+// 44 dynamic RF Channel b
+// bytes(6,7) FFFF -> 0 to 15 channels
+//bytes(8,9) FFFF -> 16 - 31 channels
+// bytes (10,11) 03FF > 32 - 44 channels
+    #define REGION_NVM_CHANNELS_MASK_SIZE            6 
 #else
     // All others
     #define REGION_NVM_CHANNELS_MASK_SIZE              1
@@ -84,13 +99,13 @@ typedef enum eRegionCN470ChannelPlan
  */
 typedef struct sRegionNvmDataGroup1
 {
-#if defined( REGION_US915 ) || defined( REGION_AU915 ) || defined( REGION_CN470 )
+#if defined( REGION_US915 ) || defined( REGION_AU915 ) || defined( REGION_CN470 ) || defined( REGION_US470 )
     /*!
      * LoRaMac channels remaining
      */
     uint16_t ChannelsMaskRemaining[ REGION_NVM_CHANNELS_MASK_SIZE ];
 #endif
-#if defined( REGION_US915 ) || defined( REGION_AU915 )
+#if defined( REGION_US915 ) || defined( REGION_AU915 ) || defined ( REGION_US470 )
     /*!
      * Index of current in use 8 bit group (0: bit 0 - 7, 1: bit 8 - 15, ...,
      * 7: bit 56 - 63)
diff --git a/src/mac/region/RegionUS470.c b/src/mac/region/RegionUS470.c
new file mode 100644
index 00000000..32e43f31
--- /dev/null
+++ b/src/mac/region/RegionUS470.c
@@ -0,0 +1,1074 @@
+#include "radio.h"
+#include "RegionCommon.h"
+#include "RegionUS470.h"
+#include "RegionBaseUS.h"
+#include <stdio.h>
+#include "tvws-board.h"
+// Definitions
+#define CHANNELS_MASK_SIZE             6  //3 RF CHAIN A + 3 RF CHAIN B
+/*
+uint32_t beacon_frequencies[22]= {
+     470312500,476312500, 482312500, 488312500, 494312500, 500312500, 506312500,512312500,
+     518312500,524312500,530312500,536312500,542312500,548312500,554312500,560312500,566312500,
+     572312500,578312500,584312500,590312500,596312500
+};*/
+/*
+uint32_t beacon_frequencies[22]= { 473187500,479187500,485187500,491187500,497187500,503187500,509187500,515187500
+,521187500,527187500,533187500,539187500,545187500,551187500,557187500,563187500,569187500,575187500,581187500
+,587187500,593187500,599187500
+};
+*/
+uint16_t tvws_enabled_channels[REGION_NVM_MAX_NB_CHANNELS]={0};
+uint32_t beacon_frequencies[22]= {
+                        473187500,479187500,473187500,479187500,473187500,
+                        479187500,473187500,479187500,473187500,479187500,
+                        473187500,479187500,473187500,479187500,473187500,
+                        479187500,473187500,479187500,473187500,479187500,
+                        473187500,479187500
+};
+ static int16_t locked_tv_channel[2]={0}; // RF CHAIN A, B
+static uint8_t current_rf_chain=0;
+uint32_t DownstreamChannelFrequencies[] =
+        {
+            470312500,470437500,470562500,470687500,470812500,470937500,471062500,471187500,471312500,471437500,471562500,471687500,471812500,471937500,472062500,472187500,472312500,472437500,472562500,472687500,472812500,472937500,473062500,473187500,473312500,473437500,473562500,473687500,473812500,473937500,474062500,474187500,474312500,474437500,474562500,474687500,474812500,474937500,475062500,475187500,475312500,475437500,475562500,475687500,
+            476312500,476437500,476562500,476687500,476812500,476937500,477062500,477187500,477312500,477437500,477562500,477687500,477812500,477937500,478062500,478187500,478312500,478437500,478562500,478687500,478812500,478937500,479062500,479187500,479312500,479437500,479562500,479687500,479812500,479937500,480062500,480187500,480312500,480437500,480562500,480687500,480812500,480937500,481062500,481187500,481312500,481437500,481562500,481687500,
+            482312500,482437500,482562500,482687500,482812500,482937500,483062500,483187500,483312500,483437500,483562500,483687500,483812500,483937500,484062500,484187500,484312500,484437500,484562500,484687500,484812500,484937500,485062500,485187500,485312500,485437500,485562500,485687500,485812500,485937500,486062500,486187500,486312500,486437500,486562500,486687500,486812500,486937500,487062500,487187500,487312500,487437500,487562500,487687500,
+            488312500,488437500,488562500,488687500,488812500,488937500,489062500,489187500,489312500,489437500,489562500,489687500,489812500,489937500,490062500,490187500,490312500,490437500,490562500,490687500,490812500,490937500,491062500,491187500,491312500,491437500,491562500,491687500,491812500,491937500,492062500,492187500,492312500,492437500,492562500,492687500,492812500,492937500,493062500,493187500,493312500,493437500,493562500,493687500,
+            494312500,494437500,494562500,494687500,494812500,494937500,495062500,495187500,495312500,495437500,495562500,495687500,495812500,495937500,496062500,496187500,496312500,496437500,496562500,496687500,496812500,496937500,497062500,497187500,497312500,497437500,497562500,497687500,497812500,497937500,498062500,498187500,498312500,498437500,498562500,498687500,498812500,498937500,499062500,499187500,499312500,499437500,499562500,499687500,
+            500312500,500437500,500562500,500687500,500812500,500937500,501062500,501187500,501312500,501437500,501562500,501687500,501812500,501937500,502062500,502187500,502312500,502437500,502562500,502687500,502812500,502937500,503062500,503187500,503312500,503437500,503562500,503687500,503812500,503937500,504062500,504187500,504312500,504437500,504562500,504687500,504812500,504937500,505062500,505187500,505312500,505437500,505562500,505687500,
+            506312500,506437500,506562500,506687500,506812500,506937500,507062500,507187500,507312500,507437500,507562500,507687500,507812500,507937500,508062500,508187500,508312500,508437500,508562500,508687500,508812500,508937500,509062500,509187500,509312500,509437500,509562500,509687500,509812500,509937500,510062500,510187500,510312500,510437500,510562500,510687500,510812500,510937500,511062500,511187500,511312500,511437500,511562500,511687500,
+            512312500,512437500,512562500,512687500,512812500,512937500,513062500,513187500,513312500,513437500,513562500,513687500,513812500,513937500,514062500,514187500,514312500,514437500,514562500,514687500,514812500,514937500,515062500,515187500,515312500,515437500,515562500,515687500,515812500,515937500,516062500,516187500,516312500,516437500,516562500,516687500,516812500,516937500,517062500,517187500,517312500,517437500,517562500,517687500,
+            518312500,518437500,518562500,518687500,518812500,518937500,519062500,519187500,519312500,519437500,519562500,519687500,519812500,519937500,520062500,520187500,520312500,520437500,520562500,520687500,520812500,520937500,521062500,521187500,521312500,521437500,521562500,521687500,521812500,521937500,522062500,522187500,522312500,522437500,522562500,522687500,522812500,522937500,523062500,523187500,523312500,523437500,523562500,523687500,
+            524312500,524437500,524562500,524687500,524812500,524937500,525062500,525187500,525312500,525437500,525562500,525687500,525812500,525937500,526062500,526187500,526312500,526437500,526562500,526687500,526812500,526937500,527062500,527187500,527312500,527437500,527562500,527687500,527812500,527937500,528062500,528187500,528312500,528437500,528562500,528687500,528812500,528937500,529062500,529187500,529312500,529437500,529562500,529687500,
+            530312500,530437500,530562500,530687500,530812500,530937500,531062500,531187500,531312500,531437500,531562500,531687500,531812500,531937500,532062500,532187500,532312500,532437500,532562500,532687500,532812500,532937500,533062500,533187500,533312500,533437500,533562500,533687500,533812500,533937500,534062500,534187500,534312500,534437500,534562500,534687500,534812500,534937500,535062500,535187500,535312500,535437500,535562500,535687500,
+            536312500,536437500,536562500,536687500,536812500,536937500,537062500,537187500,537312500,537437500,537562500,537687500,537812500,537937500,538062500,538187500,538312500,538437500,538562500,538687500,538812500,538937500,539062500,539187500,539312500,539437500,539562500,539687500,539812500,539937500,540062500,540187500,540312500,540437500,540562500,540687500,540812500,540937500,541062500,541187500,541312500,541437500,541562500,541687500,
+            542312500,542437500,542562500,542687500,542812500,542937500,543062500,543187500,543312500,543437500,543562500,543687500,543812500,543937500,544062500,544187500,544312500,544437500,544562500,544687500,544812500,544937500,545062500,545187500,545312500,545437500,545562500,545687500,545812500,545937500,546062500,546187500,546312500,546437500,546562500,546687500,546812500,546937500,547062500,547187500,547312500,547437500,547562500,547687500,
+            548312500,548437500,548562500,548687500,548812500,548937500,549062500,549187500,549312500,549437500,549562500,549687500,549812500,549937500,550062500,550187500,550312500,550437500,550562500,550687500,550812500,550937500,551062500,551187500,551312500,551437500,551562500,551687500,551812500,551937500,552062500,552187500,552312500,552437500,552562500,552687500,552812500,552937500,553062500,553187500,553312500,553437500,553562500,553687500,
+            554312500,554437500,554562500,554687500,554812500,554937500,555062500,555187500,555312500,555437500,555562500,555687500,555812500,555937500,556062500,556187500,556312500,556437500,556562500,556687500,556812500,556937500,557062500,557187500,557312500,557437500,557562500,557687500,557812500,557937500,558062500,558187500,558312500,558437500,558562500,558687500,558812500,558937500,559062500,559187500,559312500,559437500,559562500,559687500,
+            560312500,560437500,560562500,560687500,560812500,560937500,561062500,561187500,561312500,561437500,561562500,561687500,561812500,561937500,562062500,562187500,562312500,562437500,562562500,562687500,562812500,562937500,563062500,563187500,563312500,563437500,563562500,563687500,563812500,563937500,564062500,564187500,564312500,564437500,564562500,564687500,564812500,564937500,565062500,565187500,565312500,565437500,565562500,565687500,
+            566312500,566437500,566562500,566687500,566812500,566937500,567062500,567187500,567312500,567437500,567562500,567687500,567812500,567937500,568062500,568187500,568312500,568437500,568562500,568687500,568812500,568937500,569062500,569187500,569312500,569437500,569562500,569687500,569812500,569937500,570062500,570187500,570312500,570437500,570562500,570687500,570812500,570937500,571062500,571187500,571312500,571437500,571562500,571687500,
+            572312500,572437500,572562500,572687500,572812500,572937500,573062500,573187500,573312500,573437500,573562500,573687500,573812500,573937500,574062500,574187500,574312500,574437500,574562500,574687500,574812500,574937500,575062500,575187500,575312500,575437500,575562500,575687500,575812500,575937500,576062500,576187500,576312500,576437500,576562500,576687500,576812500,576937500,577062500,577187500,577312500,577437500,577562500,577687500,
+            578312500,578437500,578562500,578687500,578812500,578937500,579062500,579187500,579312500,579437500,579562500,579687500,579812500,579937500,580062500,580187500,580312500,580437500,580562500,580687500,580812500,580937500,581062500,581187500,581312500,581437500,581562500,581687500,581812500,581937500,582062500,582187500,582312500,582437500,582562500,582687500,582812500,582937500,583062500,583187500,583312500,583437500,583562500,583687500,
+            584312500,584437500,584562500,584687500,584812500,584937500,585062500,585187500,585312500,585437500,585562500,585687500,585812500,585937500,586062500,586187500,586312500,586437500,586562500,586687500,586812500,586937500,587062500,587187500,587312500,587437500,587562500,587687500,587812500,587937500,588062500,588187500,588312500,588437500,588562500,588687500,588812500,588937500,589062500,589187500,589312500,589437500,589562500,589687500,
+            590312500,590437500,590562500,590687500,590812500,590937500,591062500,591187500,591312500,591437500,591562500,591687500,591812500,591937500,592062500,592187500,592312500,592437500,592562500,592687500,592812500,592937500,593062500,593187500,593312500,593437500,593562500,593687500,593812500,593937500,594062500,594187500,594312500,594437500,594562500,594687500,594812500,594937500,595062500,595187500,595312500,595437500,595562500,595687500,
+            596312500,596437500,596562500,596687500,596812500,596937500,597062500,597187500,597312500,597437500,597562500,597687500,597812500,597937500,598062500,598187500,598312500,598437500,598562500,598687500,598812500,598937500,599062500,599187500,599312500,599437500,599562500,599687500,599812500,599937500,600062500,600187500,600312500,600437500,600562500,600687500,600812500,600937500,601062500,601187500,601312500,601437500,601562500,601687500,
+
+        };
+
+
+ 
+/*
+ * Non-volatile module context.
+ */
+static RegionNvmDataGroup1_t* RegionNvmGroup1;
+static RegionNvmDataGroup2_t* RegionNvmGroup2;
+static Band_t* RegionBands;
+
+
+uint16_t tmpchInteration=0; //TODO REMOVE
+uint16_t tvws_start_channel[2]={0}; // RF Chain
+uint32_t RegionUS470GetFrequency(uint16_t channel_index)
+{
+    return DownstreamChannelFrequencies[channel_index];
+}
+
+uint32_t GetTVWSBeaconFrequency(uint8_t rfchain)
+{
+  return beacon_frequencies[ locked_tv_channel[rfchain]];
+}
+void SetTVWSCM(uint32_t *rf_chain_if_freq)
+
+{
+    int chain_offset=0;
+     uint8_t mask_offset=0;
+    for(int ii=0;ii<2;ii++ )
+    {
+        uint32_t tvws_locked_freq= rf_chain_if_freq[ii];
+        tvws_start_channel[ii]=0;
+        mask_offset =ii*3;
+        chain_offset=ii*US470_MAX_NB_CHANNELS_IN_TV_CHANNEL;
+        // RF CHAIN A
+        //Channel 0-15
+        RegionNvmGroup2->ChannelsDefaultMask[mask_offset + 0]=0x0000;
+        RegionNvmGroup1->ChannelsMaskRemaining[mask_offset + 0]=0x0000;
+        RegionNvmGroup2->ChannelsMask[mask_offset + 0]=0x0000;
+        //Channels 16-31
+        RegionNvmGroup2->ChannelsDefaultMask[mask_offset + 1]=0x0000;
+        RegionNvmGroup1->ChannelsMaskRemaining[mask_offset + 1]=0x0000;
+        RegionNvmGroup2->ChannelsMask[mask_offset + 1]=0x0000;
+        //channels 31 -48
+        RegionNvmGroup2->ChannelsDefaultMask[mask_offset + 2]=0x0000;
+        RegionNvmGroup1->ChannelsMaskRemaining[mask_offset + 2]=0x0000;
+        RegionNvmGroup2->ChannelsMask[mask_offset + 2]=0x0000;
+        
+     
+   
+
+            for(int chn=0;chn < 44;chn++)
+            {
+                tvws_enabled_channels[ chain_offset + chn]=0;
+            }
+        
+            for(int tvch=0;tvch <22;tvch++)
+            { 
+                int found=0;
+                uint16_t frq_offset =tvch*US470_MAX_NB_CHANNELS_IN_TV_CHANNEL;
+                for(int nbch=0;nbch <44 ;nbch++)
+                {
+                    if(DownstreamChannelFrequencies[frq_offset +nbch]==tvws_locked_freq)
+                    {
+                        locked_tv_channel[ii]=tvch;
+                        found=1;
+                        break;
+                    }
+                }
+                if(found)
+                {
+                    tvws_start_channel[ii]=locked_tv_channel[ii]*US470_MAX_NB_CHANNELS_IN_TV_CHANNEL;
+
+                    for( uint8_t j = 0; j < US470_MAX_NB_CHANNELS_IN_TV_CHANNEL; j++)
+                        {
+                            RegionNvmGroup2->Channels[chain_offset + j].Frequency =DownstreamChannelFrequencies[tvws_start_channel[ii] +j];// _tvChStartFreq + US470_GUARD_FROM_TV_CH_EDGE + j*US470_STEPWIDTH_RX1_CHANNEL;
+                            RegionNvmGroup2->Channels[chain_offset + j].DrRange.Value = ( US470_TX_MAX_DATARATE << 4 ) | US470_TX_MIN_DATARATE;
+                            RegionNvmGroup2->Channels[chain_offset + j].Band = 0;
+                            RegionNvmGroup2->Channels[chain_offset + j].ChannelTimeCredits=1800000;
+                            RegionNvmGroup2->Channels[chain_offset + j].ChannelMaxTimeCredits=1800000;
+                            RegionNvmGroup2->Channels[chain_offset + j].LastChannelMaxCreditAssignTime=0;
+                            RegionNvmGroup2->Channels[chain_offset + j].LastChannelUpdateTime=0;
+                            tvws_enabled_channels[chain_offset + j]=tvws_start_channel[ii] +j;
+                        }
+                    // mask 4 channels - RF Chain A
+                   
+                    RegionNvmGroup2->ChannelsDefaultMask[mask_offset + 0]=0x0000;
+                    RegionNvmGroup1->ChannelsMaskRemaining[mask_offset + 0]=0x0000;
+                    RegionNvmGroup2->ChannelsMask[mask_offset + 0]=0x0000;
+                    //Channels 16-31
+                    RegionNvmGroup2->ChannelsDefaultMask[mask_offset +1]=0x01E0; // channels 21,22,[23],24
+                    RegionNvmGroup1->ChannelsMaskRemaining[mask_offset +1]=0x01E0;// channels 21,22,[23],24
+                    RegionNvmGroup2->ChannelsMask[mask_offset +1]=0x01E0; // channels 21,22,[23],24
+                    //channels 31 -48
+                    RegionNvmGroup2->ChannelsDefaultMask[mask_offset +2]=0x0000;
+                    RegionNvmGroup1->ChannelsMaskRemaining[mask_offset +2]=0x0000;
+                    RegionNvmGroup2->ChannelsMask[mask_offset +2]=0x000;   
+             
+                
+                    break;
+                }
+            }
+
+    }
+}
+
+ 
+
+static int8_t LimitTxPower( int8_t txPower, int8_t maxBandTxPower, int8_t datarate, uint16_t* channelsMask )
+{
+    int8_t txPowerResult = txPower;
+
+    // Limit tx power to the band max
+    txPowerResult =  RegionCommonLimitTxPower( txPower, maxBandTxPower ); 
+    if( RegionCommonCountChannels( channelsMask, 0, CHANNELS_MASK_SIZE ) < 50 )
+      {// Limit tx power to max 21
+        txPowerResult = MAX( txPower, TX_POWER_9 );
+      }
+   
+    return txPowerResult;
+}
+
+static bool VerifyRfFreq( uint32_t freq )
+{
+    // Check radio driver support
+    bool retval=false;
+    if( Radio.CheckRfFrequency( freq ) == false )
+    {
+        return false;
+    }
+    for(int n=0;n<REGION_NVM_MAX_NB_CHANNELS;n++)
+    {
+        int channel_index=tvws_enabled_channels[n];
+        if (DownstreamChannelFrequencies[channel_index]==freq)
+        {
+            retval=true;
+            break;
+
+        }
+    }
+    return retval;
+    // Rx frequencies
+}
+static bool VerifyRfChannel( uint16_t ch )
+{
+    // Check radio driver support
+    bool retval=false;
+    for(int rf_chain_no=0;rf_chain_no <2;rf_chain_no++)
+    {
+        int true_channel =tvws_start_channel[rf_chain_no] + ch;
+        for(int n=0;n<REGION_NVM_MAX_NB_CHANNELS;n++)
+        {
+    
+            if (tvws_enabled_channels[n]==true_channel)
+            {
+                retval=true;
+                break;
+
+            }
+         
+        }
+           if(retval)
+            {
+                break;
+            }
+    }
+    return retval;
+   
+}
+
+static TimerTime_t GetTimeOnAir( int8_t datarate, uint16_t pktLen )
+{
+    int8_t phyDr = DataratesUS470[datarate];
+    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsUS470 );
+
+    return Radio.TimeOnAir( MODEM_LORA, bandwidth, phyDr, 1, 8, false, pktLen, true );
+}
+
+PhyParam_t RegionUS470GetPhyParam( GetPhyParams_t* getPhy )
+{
+    PhyParam_t phyParam = { 0 };
+
+    switch( getPhy->Attribute )
+    {
+        case PHY_MIN_RX_DR:
+        {
+            phyParam.Value = US470_RX_MIN_DATARATE;
+            break;
+        }
+        case PHY_MIN_TX_DR:
+        {
+            phyParam.Value = US470_TX_MIN_DATARATE;
+            break;
+        }
+        case PHY_DEF_TX_DR:
+        {
+            phyParam.Value = US470_DEFAULT_DATARATE;
+            break;
+        }
+        case PHY_NEXT_LOWER_TX_DR:
+        {
+            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
+            {
+                .CurrentDr = getPhy->Datarate,
+                .MaxDr = ( int8_t )US470_TX_MAX_DATARATE,
+                .MinDr = ( int8_t )US470_TX_MIN_DATARATE,
+                .NbChannels = REGION_NVM_MAX_NB_CHANNELS,
+                .ChannelsMask = RegionNvmGroup2->ChannelsMask,
+                .Channels = RegionNvmGroup2->Channels,
+            };
+            phyParam.Value = RegionCommonGetNextLowerTxDr( &nextLowerTxDrParams );
+            break;
+        }
+        case PHY_MAX_TX_POWER:
+        {
+            phyParam.Value = US470_MAX_TX_POWER;
+            break;
+        }
+        case PHY_DEF_TX_POWER:
+        {
+            phyParam.Value = US470_DEFAULT_TX_POWER;
+            break;
+        }
+        case PHY_DEF_ADR_ACK_LIMIT:
+        {
+            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_LIMIT;
+            break;
+        }
+        case PHY_DEF_ADR_ACK_DELAY:
+        {
+            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_DELAY;
+            break;
+        }
+        case PHY_MAX_PAYLOAD:
+        {
+            phyParam.Value = MaxPayloadOfDatarateUS470[getPhy->Datarate];
+            break;
+        }
+        case PHY_DUTY_CYCLE:
+        {
+            phyParam.Value = US470_DUTY_CYCLE_ENABLED;
+            break;
+        }
+        case PHY_MAX_RX_WINDOW:
+        {
+            phyParam.Value = US470_MAX_RX_WINDOW;
+            break;
+        }
+        case PHY_RECEIVE_DELAY1:
+        {
+            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY1;
+            break;
+        }
+        case PHY_RECEIVE_DELAY2:
+        {
+            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY2;
+            break;
+        }
+        case PHY_JOIN_ACCEPT_DELAY1:
+        {
+            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY1;
+            break;
+        }
+        case PHY_JOIN_ACCEPT_DELAY2:
+        {
+            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY2;
+            break;
+        }
+        case PHY_RETRANSMIT_TIMEOUT:
+        {
+            phyParam.Value = ( REGION_COMMON_DEFAULT_RETRANSMIT_TIMEOUT + randr( -REGION_COMMON_DEFAULT_RETRANSMIT_TIMEOUT_RND, REGION_COMMON_DEFAULT_RETRANSMIT_TIMEOUT_RND ) );
+            break;
+        }
+        case PHY_DEF_DR1_OFFSET:
+        {
+            phyParam.Value = REGION_COMMON_DEFAULT_RX1_DR_OFFSET;
+            break;
+        }
+        case PHY_DEF_RX2_FREQUENCY:
+        {
+            phyParam.Value = DownstreamChannelFrequencies[tvws_start_channel[current_rf_chain] +3] ;//US470_RX_WND_2_FREQ;
+            break;
+        }
+        case PHY_DEF_RX2_DR:
+        {
+            phyParam.Value = US470_RX_WND_2_DR;
+            break;
+        }
+        case PHY_CHANNELS_MASK:
+        {
+            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsMask;
+            break;
+        }
+        case PHY_CHANNELS_DEFAULT_MASK:
+        {
+            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsDefaultMask;
+            break;
+        }
+        case PHY_MAX_NB_CHANNELS:
+        {
+            phyParam.Value = US470_MAX_NB_CHANNELS;
+            break;
+        }
+        case PHY_CHANNELS:
+        {
+            phyParam.Channels = RegionNvmGroup2->Channels;
+            break;
+        }
+        case PHY_DEF_UPLINK_DWELL_TIME:
+        {
+            phyParam.Value = US470_DEFAULT_UPLINK_DWELL_TIME;
+            break;
+        }
+        case PHY_DEF_DOWNLINK_DWELL_TIME:
+        {
+            phyParam.Value = REGION_COMMON_DEFAULT_DOWNLINK_DWELL_TIME;
+            break;
+        }
+        case PHY_DEF_MAX_EIRP:
+        {
+            // TODO: Should we add 2.15f here?
+            phyParam.fValue = US470_DEFAULT_MAX_ERP + 2.15f;
+            break;
+        }
+        case PHY_DEF_ANTENNA_GAIN:
+        {
+            phyParam.fValue = 0;
+            break;
+        }
+        case PHY_BEACON_CHANNEL_FREQ:
+        {
+            phyParam.Value = RegionBaseUSCalcDownlinkFrequency( getPhy->Channel,
+                                                               // US470_BEACON_CHANNEL_FREQ, 
+                                                               beacon_frequencies[locked_tv_channel[current_rf_chain]],
+                                                                US470_BEACON_CHANNEL_STEPWIDTH );
+            break;
+        }
+        case PHY_BEACON_FORMAT:
+        {
+            phyParam.BeaconFormat.BeaconSize = US470_BEACON_SIZE;
+            phyParam.BeaconFormat.Rfu1Size = US470_RFU1_SIZE;
+            phyParam.BeaconFormat.Rfu2Size = US470_RFU2_SIZE;
+            break;
+        }
+        case PHY_BEACON_CHANNEL_DR:
+        {
+            phyParam.Value = US470_BEACON_CHANNEL_DR;
+            break;
+        }
+        case PHY_BEACON_NB_CHANNELS:
+        {
+            phyParam.Value = US470_BEACON_NB_CHANNELS;
+            break;
+        }
+        case PHY_PING_SLOT_CHANNEL_FREQ:
+        {
+            phyParam.Value = RegionBaseUSCalcDownlinkFrequency( getPhy->Channel,
+                                                                //US470_PING_SLOT_CHANNEL_FREQ,
+                                                                  beacon_frequencies[locked_tv_channel[current_rf_chain]],
+                                                                US470_BEACON_CHANNEL_STEPWIDTH );
+            break;
+        }
+        case PHY_PING_SLOT_CHANNEL_DR:
+        {
+            phyParam.Value = US470_PING_SLOT_CHANNEL_DR;
+            break;
+        }
+        case PHY_PING_SLOT_NB_CHANNELS:
+        {
+            phyParam.Value = US470_BEACON_NB_CHANNELS;
+            break;
+        }
+        case PHY_SF_FROM_DR:
+        {
+            phyParam.Value = DataratesUS470[getPhy->Datarate];
+            break;
+        }
+        case PHY_BW_FROM_DR:
+        {
+            phyParam.Value = RegionCommonGetBandwidth( getPhy->Datarate, BandwidthsUS470 );
+            break;
+        }
+        default:
+        {
+            break;
+        }
+    }
+
+    return phyParam;
+}
+
+void RegionUS470SetBandTxDone( SetBandTxDoneParams_t* txDone )
+{
+   
+    ChannelParams_t *currentchannelParam =&RegionNvmGroup2->Channels[txDone->Channel];
+        RegionCommonSetChannelTxDone(currentchannelParam, &RegionBands[RegionNvmGroup2->Channels[txDone->Channel].Band],
+                               txDone->LastTxAirTime, txDone->Joined, txDone->ElapsedTimeSinceStartUp );
+}
+
+void RegionUS470InitDefaults( InitDefaultsParams_t* params )
+{
+    Band_t bands[US470_MAX_NB_BANDS] =
+    {
+       US470_BAND0
+    };
+
+    switch( params->Type )
+    {
+        case INIT_TYPE_DEFAULTS:
+        {
+            if( ( params->NvmGroup1 == NULL ) || ( params->NvmGroup2 == NULL ) )
+            {
+                return;
+            }
+
+            RegionNvmGroup1 = (RegionNvmDataGroup1_t*) params->NvmGroup1;
+            RegionNvmGroup2 = (RegionNvmDataGroup2_t*) params->NvmGroup2;
+            RegionBands = (Band_t*) params->Bands;
+
+            // Initialize 8 bit channel groups index
+            RegionNvmGroup1->JoinChannelGroupsCurrentIndex = 0;
+
+            // Initialize the join trials counter
+            RegionNvmGroup1->JoinTrialsCounter = 0;
+
+            // Default bands
+            memcpy1( ( uint8_t* )RegionBands, ( uint8_t* )bands, sizeof( Band_t ) * US470_MAX_NB_BANDS );
+
+       
+                for(int rf_chain=0;rf_chain <2;rf_chain++)
+                {
+                    uint16_t ch_offset=rf_chain*US470_MAX_NB_CHANNELS_IN_TV_CHANNEL;
+                    for( uint8_t j = 0; j < US470_MAX_NB_CHANNELS_IN_TV_CHANNEL; j++)
+                    {
+                        RegionNvmGroup2->Channels[ch_offset + j].Frequency =0;// _tvChStartFreq + US470_GUARD_FROM_TV_CH_EDGE + j*US470_STEPWIDTH_RX1_CHANNEL;
+                        RegionNvmGroup2->Channels[ch_offset + j].DrRange.Value =( US470_TX_MAX_DATARATE << 4 ) | US470_TX_MIN_DATARATE;
+                        RegionNvmGroup2->Channels[ch_offset + j].Band = 0;
+                        RegionNvmGroup2->Channels[ch_offset + j].ChannelTimeCredits=0;
+                        RegionNvmGroup2->Channels[ch_offset + j].ChannelMaxTimeCredits=0;
+                        RegionNvmGroup2->Channels[ch_offset + j].LastChannelMaxCreditAssignTime=0;
+                        RegionNvmGroup2->Channels[ch_offset + j].LastChannelUpdateTime=0;
+
+                    }
+            
+                }
+                // Default ChannelsMask
+                for(uint8_t i = 0; i < REGION_NVM_CHANNELS_MASK_SIZE -1 ; i++)
+                {
+                    RegionNvmGroup2->ChannelsDefaultMask[i] = 0x0000;
+                }
+                RegionNvmGroup2->ChannelsDefaultMask[2] = 0x0000;
+                RegionNvmGroup2->ChannelsDefaultMask[5] = 0x0000;
+        
+           
+                // Copy channels default mask
+                RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
+
+                // Copy into channels mask remaining
+                RegionCommonChanMaskCopy( RegionNvmGroup1->ChannelsMaskRemaining, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
+            break;
+        }
+        case INIT_TYPE_RESET_TO_DEFAULT_CHANNELS:
+        {
+            // Intentional fallthrough
+        }
+        case INIT_TYPE_ACTIVATE_DEFAULT_CHANNELS:
+        {
+            // Copy channels default mask
+            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
+
+            for( uint8_t i = 0; i < CHANNELS_MASK_SIZE; i++ )
+            { // Copy-And the channels mask
+                RegionNvmGroup1->ChannelsMaskRemaining[i] &= RegionNvmGroup2->ChannelsMask[i];
+            }
+            break;
+        }
+        default:
+        {
+            break;
+        }
+    }
+}
+
+bool RegionUS470Verify( VerifyParams_t* verify, PhyAttribute_t phyAttribute )
+{
+    switch( phyAttribute )
+    {
+        case PHY_FREQUENCY:
+        {
+            return VerifyRfFreq( verify->Frequency );
+        }
+        case PHY_TX_DR:
+        {
+            return RegionCommonValueInRange( verify->DatarateParams.Datarate, US470_TX_MIN_DATARATE, US470_TX_MAX_DATARATE );
+        }
+        case PHY_DEF_TX_DR:
+        {
+            return RegionCommonValueInRange( verify->DatarateParams.Datarate, DR_0, DR_5 );
+        }
+        case PHY_RX_DR:
+        {
+            return RegionCommonValueInRange( verify->DatarateParams.Datarate, US470_RX_MIN_DATARATE, US470_RX_MAX_DATARATE );
+        }
+        case PHY_DEF_TX_POWER:
+        case PHY_TX_POWER:
+        {
+            // Remark: switched min and max!
+            return RegionCommonValueInRange( verify->TxPower, US470_MAX_TX_POWER, US470_MIN_TX_POWER );
+        }
+        case PHY_DUTY_CYCLE:
+        {
+            return US470_DUTY_CYCLE_ENABLED;
+        }
+        default:
+            return false;
+    }
+}
+
+void RegionUS470ApplyCFList( ApplyCFListParams_t* applyCFList )
+{
+    // TODO: Not implemented
+    // // Size of the optional CF list must be 16 byte
+   if( applyCFList->Size != 16 )
+    {
+      return;
+   }
+
+    // // Last byte CFListType must be 0x01 to indicate the CFList contains a series of ChMask fields
+   if( applyCFList->Payload[15] != 0x01 )
+    {
+      return;
+    }
+
+    // // ChMask0 - ChMask4 must be set (every ChMask has 16 bit)
+    for( uint8_t chMaskItr = 0, cntPayload = 0; chMaskItr <= 4; chMaskItr++, cntPayload+=2 )
+     {
+     RegionNvmGroup2->ChannelsMask[chMaskItr] = (uint16_t) (0x00FF & applyCFList->Payload[cntPayload]);
+       RegionNvmGroup2->ChannelsMask[chMaskItr] |= (uint16_t) (applyCFList->Payload[cntPayload+1] << 8);
+
+    //     // Set the channel mask to the remaining
+      RegionNvmGroup1->ChannelsMaskRemaining[chMaskItr] &= RegionNvmGroup2->ChannelsMask[chMaskItr];
+     }
+}
+ 
+bool RegionUS470ChanMaskSet( ChanMaskSetParams_t* chanMaskSet )
+{
+    uint8_t nbChannels = RegionCommonCountChannels( chanMaskSet->ChannelsMaskIn, 0, CHANNELS_MASK_SIZE -1 );
+
+    // Check the number of active channels
+    if( ( nbChannels < 2 ) &&
+        ( nbChannels > 0 ) )
+    {
+        return false;
+    }
+
+    switch( chanMaskSet->ChannelsMaskType )
+    {
+        case CHANNELS_MASK:
+        {
+            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
+
+            for( uint8_t i = 0; i < CHANNELS_MASK_SIZE; i++ )
+            { // Copy-And the channels mask
+                RegionNvmGroup1->ChannelsMaskRemaining[i] &= RegionNvmGroup2->ChannelsMask[i];
+            }
+            break;
+        }
+        case CHANNELS_DEFAULT_MASK:
+        {
+            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsDefaultMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
+            break;
+        }
+        default:
+            return false;
+    }
+    return true;
+}
+
+void RegionUS470ComputeRxWindowParameters( int8_t datarate, uint8_t minRxSymbols, uint32_t rxError, RxConfigParams_t *rxConfigParams )
+{
+    uint32_t tSymbolInUs = 0;
+
+    // Get the datarate, perform a boundary check
+    rxConfigParams->Datarate = MIN( datarate, US470_RX_MAX_DATARATE );
+    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsUS470 );
+
+    tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesUS470[rxConfigParams->Datarate], BandwidthsUS470[rxConfigParams->Datarate] );
+
+    RegionCommonComputeRxWindowParameters( tSymbolInUs, minRxSymbols, rxError, Radio.GetWakeupTime( ), &rxConfigParams->WindowTimeout, &rxConfigParams->WindowOffset );
+}
+extern volatile uint32_t tx_cntr;
+bool RegionUS470RxConfig( RxConfigParams_t* rxConfig, int8_t* datarate )
+{
+    int8_t dr = rxConfig->Datarate;
+    int8_t phyDr = 0;
+    uint32_t frequency = rxConfig->Frequency;
+   int offset =locked_tv_channel[current_rf_chain]*US470_MAX_NB_CHANNELS_IN_TV_CHANNEL;
+    if( Radio.GetStatus( ) != RF_IDLE )
+    {
+        return false;
+    }
+
+    if( rxConfig->RxSlot == RX_SLOT_WIN_1 )
+    {
+        
+        SetTVWSBand(RF_STATE_RX_EN_LNA); //US470
+        // Apply window 1 frequency
+        frequency = DownstreamChannelFrequencies[offset + rxConfig->Channel % 8];//US470_FIRST_RX1_CHANNEL + ( rxConfig->Channel % 8 ) * US470_STEPWIDTH_RX1_CHANNEL;
+
+       
+    }
+    else  if( rxConfig->RxSlot == RX_SLOT_WIN_2 )
+    {
+        frequency =  DownstreamChannelFrequencies[offset +3];
+        dr=8;
+    }
+   
+    // Read the physical datarate from the datarates table // SF
+    phyDr = DataratesUS470[dr];
+
+    Radio.SetChannel( frequency );
+
+    // Radio configuration
+    Radio.SetRxConfig( MODEM_LORA, rxConfig->Bandwidth, phyDr, 1, 0, 8, rxConfig->WindowTimeout, false, 0, false, 0, 0, true, rxConfig->RxContinuous );
+
+    Radio.SetMaxPayloadLength( MODEM_LORA, MaxPayloadOfDatarateUS470[dr] + LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE );
+
+    *datarate = (uint8_t) dr;
+     printf(" Rxfrq %ld, ch=%d sl=%d sf=%d dr=%d\r\n",frequency,rxConfig->Channel % 8,rxConfig->RxSlot ,phyDr,dr);
+     
+    return true;
+}
+
+bool RegionUS470TxConfig( TxConfigParams_t* txConfig, int8_t* txPower, TimerTime_t* txTimeOnAir )
+{
+    int8_t phyDr = DataratesUS470[txConfig->Datarate];
+    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, RegionBands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, RegionNvmGroup2->ChannelsMask );
+    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsUS470 );
+    int8_t phyTxPower = 0;
+    current_rf_chain=RF_CHAIN_A;
+      SetTVWSBand(current_rftx_band);
+    if (tvws_start_channel[RF_CHAIN_B] >0 && (txConfig->Channel >=tvws_start_channel[RF_CHAIN_B])) //if tvws_start_channel[RF_CHAIN_B]==0 WSDB not acquired
+    {
+        current_rf_chain=RF_CHAIN_B;
+    }
+    // Calculate physical TX power
+    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US470_DEFAULT_MAX_ERP, 0 );
+ if(phyTxPower ==0)
+ {
+    phyTxPower=US470_DEFAULT_MAX_ERP;
+ }
+    // Setup the radio frequency
+    Radio.SetChannel( RegionNvmGroup2->Channels[txConfig->Channel].Frequency );
+    printf("Tx Config freq %d sf=%d dr=%d\r\n",RegionNvmGroup2->Channels[txConfig->Channel].Frequency,phyDr,txConfig->Datarate);
+
+    Radio.SetTxConfig( MODEM_LORA, phyTxPower, 0, bandwidth, phyDr, 1, 8, false, true, 0, 0, false, 4000 );
+
+    // Setup maximum payload lenght of the radio driver
+    Radio.SetMaxPayloadLength( MODEM_LORA, txConfig->PktLen );
+
+    // Update time-on-air
+    *txTimeOnAir = GetTimeOnAir( txConfig->Datarate, txConfig->PktLen );
+
+    *txPower = txPowerLimited;
+   
+    return true;
+}
+
+uint8_t RegionUS470LinkAdrReq( LinkAdrReqParams_t* linkAdrReq, int8_t* drOut, int8_t* txPowOut, uint8_t* nbRepOut, uint8_t* nbBytesParsed )
+{
+    // TODO: Not supported in US470 for now
+    uint8_t status = 0x0F;
+    RegionCommonLinkAdrParams_t linkAdrParams = { 0 };
+    uint8_t nextIndex = 0;
+    uint8_t bytesProcessed = 0;
+    uint16_t channelsMask[6] = { 0, 0, 0 ,0,0,0};
+    GetPhyParams_t getPhy;
+    PhyParam_t phyParam;
+    RegionCommonLinkAdrReqVerifyParams_t linkAdrVerifyParams;
+
+    // Initialize local copy of channels mask
+   RegionCommonChanMaskCopy( channelsMask, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
+
+   while( bytesProcessed < linkAdrReq->PayloadSize )
+ {
+        nextIndex = RegionCommonParseLinkAdrReq( &( linkAdrReq->Payload[bytesProcessed] ), &linkAdrParams );
+
+     if( nextIndex == 0 )
+        break; // break loop, since no more request has been found
+
+    //     // Update bytes processed
+        bytesProcessed += nextIndex;
+
+    //     // Revert status, as we only check the last ADR request for the channel mask KO
+       status = 0x07;
+
+        if( linkAdrParams.ChMaskCtrl == 6 )
+        {
+            // Enable all 125 kHz channels
+            channelsMask[0] = 0xFFFF;
+            channelsMask[1] = 0xFFFF;
+            channelsMask[2] = 0x0FFF;
+            channelsMask[3] = 0xFFFF;
+            channelsMask[4] = 0xFFFF;
+            channelsMask[5] = 0x0FFF;
+       
+             // Apply chMask to channels 64 to 71
+    //         channelsMask[4] = linkAdrParams.ChMask & CHANNELS_MASK_500KHZ_MASK;
+        }
+        else if( linkAdrParams.ChMaskCtrl == 7 )
+        {
+    //         // Disable all 125 kHz channels
+            channelsMask[0] = 0x0000;
+            channelsMask[1] = 0x0000;
+            channelsMask[2] = 0x0000;
+            channelsMask[3] = 0x0000;
+            channelsMask[4] = 0x0000;
+            channelsMask[5] = 0x0000;       
+      }
+       else if( linkAdrParams.ChMaskCtrl == 5 )
+        {
+    //         // Start value for comparision
+           uint8_t bitMask = 1;
+
+          // cntChannelMask for channelsMask[0] until channelsMask[3]
+           uint8_t cntChannelMask = 0;
+
+         // i will be 1, 2, 3, ..., 7
+          for( uint8_t i = 0; i <= 7; i++ )
+            {
+    //             // 8 MSBs of ChMask are RFU
+    //             // Checking if the ChMask is set, then true
+               if( ( ( linkAdrParams.ChMask & 0x00FF ) & ( bitMask << i ) ) != 0 )
+                 {
+                  if( ( i % 2 ) == 0 )
+                   {
+                         // Enable a bank of 8 125kHz channels, 8 LSBs
+                         channelsMask[cntChannelMask] |= 0x00FF;
+                     // Enable the corresponding 500kHz channel
+                  //       channelsMask[4] |= ( bitMask << i );
+                  }
+                   else
+                    {
+    //                     // Enable a bank of 8 125kHz channels, 8 MSBs
+                        channelsMask[cntChannelMask] |= 0xFF00;
+    //                     // Enable the corresponding 500kHz channel
+                        channelsMask[4] |= ( bitMask << i );
+                      // cntChannelMask increment for uneven i
+                       cntChannelMask++;
+                   }
+               }
+    //             // ChMask is not set
+                else
+                  {
+                   if( ( i % 2 ) == 0 )
+                    {
+    //                     // Disable a bank of 8 125kHz channels, 8 LSBs
+                       channelsMask[cntChannelMask] &= 0xFF00;
+    //                     // Disable the corresponding 500kHz channel
+                        channelsMask[4] &= ~( bitMask << i );
+                   }
+                    else
+                  {
+    //                     // Enable a bank of 8 125kHz channels, 8 MSBs
+                      channelsMask[cntChannelMask] &= 0x00FF;
+    //                     // Disable the corresponding 500kHz channel
+                      channelsMask[4] &= ~( bitMask << i );
+    //                     // cntChannelMask increment for uneven i
+                         cntChannelMask++;
+                    }
+                }
+             }
+         }
+        else
+        {
+             channelsMask[linkAdrParams.ChMaskCtrl] = linkAdrParams.ChMask;
+         }
+    }
+
+    // // FCC 15.247 paragraph F mandates to hop on at least 2 125 kHz channels
+  if( ( linkAdrParams.Datarate < DR_4 ) && ( RegionCommonCountChannels( channelsMask, 0, 4 ) < 2 ) )
+  {
+         status &= 0xFE; // Channel mask KO
+      }
+
+    // // Get the minimum possible datarate
+    getPhy.Attribute = PHY_MIN_TX_DR;
+     getPhy.UplinkDwellTime = linkAdrReq->UplinkDwellTime;
+     phyParam = RegionUS470GetPhyParam( &getPhy );
+
+    linkAdrVerifyParams.Status = status;
+    linkAdrVerifyParams.AdrEnabled = linkAdrReq->AdrEnabled;
+    linkAdrVerifyParams.Datarate = linkAdrParams.Datarate;
+    linkAdrVerifyParams.TxPower = linkAdrParams.TxPower;
+    linkAdrVerifyParams.NbRep = linkAdrParams.NbRep;
+    linkAdrVerifyParams.CurrentDatarate = linkAdrReq->CurrentDatarate;
+    linkAdrVerifyParams.CurrentTxPower = linkAdrReq->CurrentTxPower;
+    linkAdrVerifyParams.CurrentNbRep = linkAdrReq->CurrentNbRep;
+    linkAdrVerifyParams.NbChannels = US470_MAX_NB_CHANNELS_IN_TV_CHANNEL;
+    linkAdrVerifyParams.ChannelsMask = channelsMask;
+    linkAdrVerifyParams.MinDatarate = ( int8_t )phyParam.Value;
+    linkAdrVerifyParams.MaxDatarate = US470_TX_MAX_DATARATE;
+    linkAdrVerifyParams.Channels = RegionNvmGroup2->Channels;
+    linkAdrVerifyParams.MinTxPower = US470_MIN_TX_POWER;
+    linkAdrVerifyParams.MaxTxPower = US470_MAX_TX_POWER;
+    linkAdrVerifyParams.Version = linkAdrReq->Version;
+
+     // Verify the parameters and update, if necessary
+    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
+
+    // // Update channelsMask if everything is correct
+     if( status == 0x07 )
+     {
+        // Copy Mask
+         RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, channelsMask, 6 );
+
+            RegionNvmGroup1->ChannelsMaskRemaining[0] &= RegionNvmGroup2->ChannelsMask[0];
+            RegionNvmGroup1->ChannelsMaskRemaining[1] &= RegionNvmGroup2->ChannelsMask[1];
+            RegionNvmGroup1->ChannelsMaskRemaining[2] &= RegionNvmGroup2->ChannelsMask[2];
+            RegionNvmGroup1->ChannelsMaskRemaining[3] &= RegionNvmGroup2->ChannelsMask[3];
+            RegionNvmGroup1->ChannelsMaskRemaining[4] &= RegionNvmGroup2->ChannelsMask[4];
+            RegionNvmGroup1->ChannelsMaskRemaining[5] &= RegionNvmGroup2->ChannelsMask[5];
+      
+     }
+
+    // // Update status variables
+    *drOut = linkAdrParams.Datarate;
+      *txPowOut = linkAdrParams.TxPower;
+    *nbRepOut = linkAdrParams.NbRep;
+    *nbBytesParsed = bytesProcessed;
+
+    return status;
+}
+
+uint8_t RegionUS470RxParamSetupReq( RxParamSetupReqParams_t* rxParamSetupReq )
+{
+    uint8_t status = 0x07;
+
+    // Verify radio frequency
+    if( VerifyRfFreq( rxParamSetupReq->Frequency ) == false )
+    {
+        status &= 0xFE; // Channel frequency KO
+    }
+
+    // Verify datarate
+    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, US470_RX_MIN_DATARATE, US470_RX_MAX_DATARATE ) == false )
+    {
+        status &= 0xFD; // Datarate KO
+    }
+
+    return status;
+}
+
+int8_t RegionUS470NewChannelReq( NewChannelReqParams_t* newChannelReq )
+{
+    // Do not accept the request
+    return -1;
+}
+
+int8_t RegionUS470TxParamSetupReq( TxParamSetupReqParams_t* txParamSetupReq )
+{
+    // Do not accept the request
+    return -1;
+}
+
+int8_t RegionUS470DlChannelReq( DlChannelReqParams_t* dlChannelReq )
+{
+    // Do not accept the request
+    return -1;
+}
+
+int8_t RegionUS470AlternateDr( int8_t currentDr, AlternateDrType_t type )
+{
+    // Alternates the data rate according to the channel sequence:
+    // Eight times a 125kHz DR_0 and then one 500kHz DR_4 channel
+    if( type == ALTERNATE_DR )
+    {
+        RegionNvmGroup1->JoinTrialsCounter++;
+    }
+    else
+    {
+        RegionNvmGroup1->JoinTrialsCounter--;
+    }
+
+    currentDr++;
+
+    // Verify datarate
+    if( RegionCommonValueInRange( currentDr, US470_TX_MIN_DATARATE, US470_TX_MAX_DATARATE ) == false )
+    {
+       currentDr = US470_TX_MIN_DATARATE;
+    }
+    
+    return currentDr;
+}
+
+LoRaMacStatus_t RegionUS470NextChannel( NextChanParams_t* nextChanParams, uint8_t* channel, TimerTime_t* time, TimerTime_t* aggregatedTimeOff )
+{
+    uint8_t nbEnabledChannels = 0;
+    uint8_t nbRestrictedChannels = 0;
+    uint8_t enabledChannels[REGION_NVM_MAX_NB_CHANNELS] = { 0 };
+    RegionCommonIdentifyChannelsParam_t identifyChannelsParam;
+    RegionCommonCountNbOfEnabledChannelsParams_t countChannelsParams;
+    LoRaMacStatus_t status = LORAMAC_STATUS_NO_CHANNEL_FOUND;
+
+    // Count 125kHz channels
+    if( RegionCommonCountChannels( RegionNvmGroup1->ChannelsMaskRemaining, 0, CHANNELS_MASK_SIZE ) == 0 )
+    { // Reactivate default channels
+        RegionCommonChanMaskCopy( RegionNvmGroup1->ChannelsMaskRemaining, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
+
+        RegionNvmGroup1->JoinChannelGroupsCurrentIndex = 0;
+    }
+     if(!VerifyRfChannel(*channel))
+     {
+        *channel=tvws_enabled_channels[0];
+     }
+
+    // Search how many channels are enabled
+    countChannelsParams.Joined = nextChanParams->Joined;
+    countChannelsParams.Datarate = nextChanParams->Datarate;
+    countChannelsParams.ChannelsMask = RegionNvmGroup1->ChannelsMaskRemaining;
+    countChannelsParams.Channels = RegionNvmGroup2->Channels;
+    countChannelsParams.Bands = RegionBands;
+    countChannelsParams.MaxNbChannels = REGION_NVM_MAX_NB_CHANNELS;
+    countChannelsParams.JoinChannels = NULL;
+
+    identifyChannelsParam.AggrTimeOff = nextChanParams->AggrTimeOff;
+    identifyChannelsParam.LastAggrTx = nextChanParams->LastAggrTx;
+    identifyChannelsParam.DutyCycleEnabled = nextChanParams->DutyCycleEnabled;
+    identifyChannelsParam.MaxBands = US470_MAX_NB_BANDS;
+
+    identifyChannelsParam.CountNbOfEnabledChannelsParam = &countChannelsParams;
+
+    identifyChannelsParam.ElapsedTimeSinceStartUp = nextChanParams->ElapsedTimeSinceStartUp;
+    identifyChannelsParam.LastTxIsJoinRequest = nextChanParams->LastTxIsJoinRequest;
+    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
+
+  ChannelParams_t *currentchannelParam =&RegionNvmGroup2->Channels[*channel];
+        status = RegionCommonChannelIdentifyChannels(currentchannelParam, &identifyChannelsParam, aggregatedTimeOff, enabledChannels,
+                                           &nbEnabledChannels, &nbRestrictedChannels, time );
+ //   status = RegionCommonChannelIdentifyChannels(currentchannelParam, &identifyChannelsParam, aggregatedTimeOff, enabledChannels,
+ //                                          &nbEnabledChannels, &nbRestrictedChannels, time );
+
+     if( status == LORAMAC_STATUS_OK )
+    {
+        if( nextChanParams->Joined == true )
+        {
+            // Choose randomly on of the remaining channels
+            *channel = enabledChannels[randr( 0, nbEnabledChannels - 1 )];
+        }
+        else
+        {
+            // For rapid network acquisition in mixed gateway channel plan environments, the device
+            // follow a random channel selection sequence. It probes alternating one out of a
+            // group of eight 125 kHz channels followed by probing one 500 kHz channel each pass.
+            // Each time a 125 kHz channel will be selected from another group.
+
+            // 125kHz Channels (0 - 63) DR0
+         //   if( nextChanParams->Datarate == DR_0 )
+            {
+                if(RegionNvmGroup1->JoinChannelGroupsCurrentIndex>3)
+                {
+                    RegionNvmGroup1->JoinChannelGroupsCurrentIndex=0;
+                }
+                if( RegionBaseUSComputeNext125kHzJoinChannel( ( uint16_t* ) RegionNvmGroup1->ChannelsMaskRemaining,
+                    &RegionNvmGroup1->JoinChannelGroupsCurrentIndex, channel ) == LORAMAC_STATUS_PARAMETER_INVALID )
+                {
+                    return LORAMAC_STATUS_PARAMETER_INVALID;
+                }
+            }
+            // 500kHz Channels (64 - 71) DR4
+           
+        }
+
+        // Disable the channel in the mask
+        RegionCommonChanDisable( RegionNvmGroup1->ChannelsMaskRemaining, *channel, REGION_NVM_MAX_NB_CHANNELS );
+    }
+    return status;
+}
+
+LoRaMacStatus_t RegionUS470ChannelAdd( ChannelAddParams_t* channelAdd )
+{
+    return LORAMAC_STATUS_PARAMETER_INVALID;
+}
+
+bool RegionUS470ChannelsRemove( ChannelRemoveParams_t* channelRemove  )
+{
+    return LORAMAC_STATUS_PARAMETER_INVALID;
+}
+
+uint8_t RegionUS470ApplyDrOffset( uint8_t downlinkDwellTime, int8_t dr, int8_t drOffset )
+{
+
+    int8_t datarate = DatarateOffsetsUS470[dr][drOffset];
+//printf("\tDR=%d,OFF=%d, val=%d\r\n",dr,drOffset,datarate);
+    if( datarate < 0 )
+   {
+         datarate = DR_0;
+      }
+    return datarate;
+  
+}
+
+void RegionUS470RxBeaconSetup( RxBeaconSetup_t* rxBeaconSetup, uint8_t* outDr )
+{
+    RegionCommonRxBeaconSetupParams_t regionCommonRxBeaconSetup;
+
+    regionCommonRxBeaconSetup.Datarates = DataratesUS470;
+    regionCommonRxBeaconSetup.Frequency = rxBeaconSetup->Frequency;
+    regionCommonRxBeaconSetup.BeaconSize = US470_BEACON_SIZE;
+    regionCommonRxBeaconSetup.BeaconDatarate = US470_BEACON_CHANNEL_DR;
+    regionCommonRxBeaconSetup.BeaconChannelBW = US470_BEACON_CHANNEL_BW;
+    regionCommonRxBeaconSetup.RxTime = rxBeaconSetup->RxTime;
+    regionCommonRxBeaconSetup.SymbolTimeout = rxBeaconSetup->SymbolTimeout;
+
+    RegionCommonRxBeaconSetup( &regionCommonRxBeaconSetup );
+
+    // Store downlink datarate
+    *outDr = US470_BEACON_CHANNEL_DR;
+}
+ 
diff --git a/src/mac/region/RegionUS470.h b/src/mac/region/RegionUS470.h
new file mode 100644
index 00000000..636c0d99
--- /dev/null
+++ b/src/mac/region/RegionUS470.h
@@ -0,0 +1,445 @@
+#ifndef __REGION_US470_H__
+#define __REGION_US470_H__
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include "region/Region.h"
+
+/*!
+ * LoRaMac maximum number of TV channels
+ */
+#define US470_MAX_NB_TV_CHANNELS                    22
+#define US470_MAX_TV_CHANNELS                    22
+/*!
+ * LoRaMac maximum number of TV channels
+ */
+#define US470_MAX_NB_CHANNELS_IN_TV_CHANNEL         44  /*! We are assuming that each channel width is 125 kHz */
+
+/*!
+ * LoRaMac maximum number of channels
+ */
+#define US470_MAX_NB_CHANNELS     (((uint16_t)US470_MAX_NB_TV_CHANNELS )* ((uint16_t)US470_MAX_NB_CHANNELS_IN_TV_CHANNEL)) /*! Num of TV Channels * Num of NB channels in each TV channel */
+
+/*!
+ * Minimal datarate that can be used by the node
+ */
+#define US470_TX_MIN_DATARATE                       DR_0
+
+/*!
+ * Maximal datarate that can be used by the node
+ */
+#define US470_TX_MAX_DATARATE                       DR_4
+
+/*!
+ * Minimal datarate that can be used by the node
+ */
+#define US470_RX_MIN_DATARATE                       DR_8
+
+/*!
+ * Maximal datarate that can be used by the node
+ */
+#define US470_RX_MAX_DATARATE                       DR_13
+
+/*!
+ * Default datarate used by the node
+ */
+#define US470_DEFAULT_DATARATE                      DR_1
+
+/*!
+ * Minimal Rx1 receive datarate offset
+ */
+#define US470_MIN_RX1_DR_OFFSET                     0
+
+/*!
+ * Maximal Rx1 receive datarate offset
+ */
+#define US470_MAX_RX1_DR_OFFSET                     3
+
+/*!
+ * Minimal Tx output power that can be used by the node
+ */
+#define US470_MIN_TX_POWER                          TX_POWER_14
+
+/*!
+ * Maximal Tx output power that can be used by the node
+ */
+#define US470_MAX_TX_POWER                          TX_POWER_0
+
+/*!
+ * Default Tx output power used by the node
+ */
+#define US470_DEFAULT_TX_POWER                      TX_POWER_0
+
+/*!
+ * Default Max ERP
+ */
+#define US470_DEFAULT_MAX_ERP                      18.0f
+
+/*!
+ * Enabled or disabled the duty cycle
+ */
+#define US470_DUTY_CYCLE_ENABLED                    1
+
+/*!
+ * Maximum RX window duration
+ */
+#define US470_MAX_RX_WINDOW                         24000
+
+/*!
+ * Second reception window channel frequency definition.
+ */
+#define US470_RX_WND_2_FREQ                    471187500 //  471812500      
+
+/*!
+ * Second reception window channel datarate definition.
+ */
+#define US470_RX_WND_2_DR                           DR_8
+
+/*!
+ * Default uplink dwell time configuration
+ */
+#define US470_DEFAULT_UPLINK_DWELL_TIME             0
+
+/*
+ * CLASS B
+ */
+/*!
+ * Beacon frequency
+ */
+#define US470_BEACON_CHANNEL_FREQ                   472062500
+
+
+/*!
+ * Beacon frequency channel stepwidth
+ */
+#define US470_BEACON_CHANNEL_STEPWIDTH              6000000
+
+/*!
+ * Ping slot channel frequency
+ */
+#define US470_PING_SLOT_CHANNEL_FREQ                472062500
+
+
+/*!
+ * Number of possible beacon channels
+ */
+#define US470_BEACON_NB_CHANNELS                    US470_MAX_NB_TV_CHANNELS /*! 22 TV channels */
+
+/*!
+ * Payload size of a beacon frame
+ */
+#define US470_BEACON_SIZE                           23
+
+/*!
+ * Size of RFU 1 field
+ */
+#define US470_RFU1_SIZE                             4
+
+/*!
+ * Size of RFU 2 field
+ */
+#define US470_RFU2_SIZE                             3
+
+/*!
+ * Datarate of the beacon channel
+ */
+#define US470_BEACON_CHANNEL_DR                     DR_8
+
+/*!
+ * Bandwith of the beacon channel
+ */
+#define US470_BEACON_CHANNEL_BW                     0
+
+/*!
+ * Ping slot channel datarate
+ */
+#define US470_PING_SLOT_CHANNEL_DR                  DR_8
+
+/*!
+ * LoRaMac maximum number of bands
+ */
+#define US470_MAX_NB_BANDS                          1
+
+/*!
+ * Band 0 definition
+ * Band = { DutyCycle, TxMaxPower, LastBandUpdateTime, LastMaxCreditAssignTime, TimeCredits, MaxTimeCredits, ReadyForTransmission }
+ */
+#define US470_BAND0                                 { 1, US470_MAX_TX_POWER, 0, 0, 0, 0, 0 } //  100.0 %
+
+/*!
+ * Definition of the TV band
+ */
+
+/*!
+ * Defines the starting frequency of the first TV channel in the band
+ */
+#define US470_FIRST_TV_CH_FREQ                      (( (uint32_t) 470000000 ))
+
+/*!
+ * Defines the starting frequency of the last TV channel in the band
+ */
+#define US470_LAST_TV_CH_FREQ                      (( (uint32_t) 596000000 ))
+
+/*!
+ * Defines the step width of the TV channels
+ */
+#define US470_STEPWIDTH_TV_CH                       ( (uint32_t) 6000000 )
+
+/*!
+ * Defines the step width of the TV channels
+ */
+#define US470_GUARD_FROM_TV_CH_EDGE                 ( (uint32_t) 312500 )
+
+/*!
+ * Defines the first channel for RX window 1 for US band
+ */
+#define US470_FIRST_RX1_CHANNEL                     ( US470_FIRST_TV_CH_FREQ + US470_GUARD_FROM_TV_CH_EDGE )
+
+/*!
+ * Defines the last channel for RX window 1 for US band
+ */
+#define US470_LAST_RX1_CHANNEL                      ( US470_LAST_TV_CH_FREQ + US470_STEPWIDTH_TV_CH - US470_GUARD_FROM_TV_CH_EDGE )
+
+/*!
+ * Defines the step width of the channels for RX window 1
+ */
+#define US470_STEPWIDTH_RX1_CHANNEL                 ( (uint32_t) 125000 )
+
+/*!
+ * Data rates table definition Stor
+ */      
+static const uint8_t DataratesUS470[]  = {10, 9, 8,  7,  8,  0,  0, 0, 12, 11, 10, 9, 8, 7, 0, 0};//{ 12, 11, 10,  9,  8,  7,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+                                        /* 0,  1, 2, 3,  0 , 5,   6, 7, 8,  9, 10 ,11,12, 13*/
+/*!
+ * Bandwidths table definition in Hz
+ * TODO: To comply with gateway supported BW, we are now using 125 kHz.
+ */
+static const uint32_t BandwidthsUS470[] = { 125000, 125000, 125000, 125000, 125000, 125000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+
+/*!
+ * Up/Down link data rates offset definition
+ */
+static const int8_t DatarateOffsetsUS470[5][4] =
+{
+     { DR_10, DR_9 , DR_8 , DR_8  }, // DR_0
+    { DR_11, DR_10, DR_9 , DR_8  }, // DR_1
+    { DR_12, DR_11, DR_10, DR_9  }, // DR_2
+    { DR_13, DR_12, DR_11, DR_10 }, // DR_3
+    { DR_13, DR_13, DR_12, DR_11 }, // DR_4
+ };
+
+/*!
+ * Maximum payload with respect to the datarate index.
+ */
+static const uint8_t MaxPayloadOfDatarateUS470[] =  { 11, 53, 125, 242, 242, 0, 0, 0, 53, 129, 242, 242, 242, 242, 0, 0 };//{ 242, 242, 242, 242, 242, 242, 242,242, 242, 242, 242, 242, 242, 242, 242, 242 };
+
+/*!
+ * \brief The function gets a value of a specific phy attribute.
+ *
+ * \param [IN] getPhy Pointer to the function parameters.
+ *
+ * \retval Returns a structure containing the PHY parameter.
+ */
+PhyParam_t RegionUS470GetPhyParam( GetPhyParams_t* getPhy );
+
+/*!
+ * \brief Updates the last TX done parameters of the current channel.
+ *
+ * \param [IN] txDone Pointer to the function parameters.
+ */
+void RegionUS470SetBandTxDone( SetBandTxDoneParams_t* txDone );
+
+/*!
+ * \brief Initializes the channels masks and the channels.
+ *
+ * \param [IN] type Sets the initialization type.
+ */
+void RegionUS470InitDefaults( InitDefaultsParams_t* params );
+
+/*!
+ * \brief Verifies a parameter.
+ *
+ * \param [IN] verify Pointer to the function parameters.
+ *
+ * \param [IN] type Sets the initialization type.
+ *
+ * \retval Returns true, if the parameter is valid.
+ */
+bool RegionUS470Verify( VerifyParams_t* verify, PhyAttribute_t phyAttribute );
+
+/*!
+ * \brief The function parses the input buffer and sets up the channels of the
+ *        CF list.
+ *
+ * \param [IN] applyCFList Pointer to the function parameters.
+ */
+void RegionUS470ApplyCFList( ApplyCFListParams_t* applyCFList );
+
+/*!
+ * \brief Sets a channels mask.
+ *
+ * \param [IN] chanMaskSet Pointer to the function parameters.
+ *
+ * \retval Returns true, if the channels mask could be set.
+ */
+bool RegionUS470ChanMaskSet( ChanMaskSetParams_t* chanMaskSet );
+
+/*!
+ * Computes the Rx window timeout and offset.
+ *
+ * \param [IN] datarate     Rx window datarate index to be used
+ *
+ * \param [IN] minRxSymbols Minimum required number of symbols to detect an Rx frame.
+ *
+ * \param [IN] rxError      System maximum timing error of the receiver. In milliseconds
+ *                          The receiver will turn on in a [-rxError : +rxError] ms
+ *                          interval around RxOffset
+ *
+ * \param [OUT]rxConfigParams Returns updated WindowTimeout and WindowOffset fields.
+ */
+void RegionUS470ComputeRxWindowParameters( int8_t datarate, uint8_t minRxSymbols, uint32_t rxError, RxConfigParams_t *rxConfigParams );
+
+/*!
+ * \brief Configuration of the RX windows.
+ *
+ * \param [IN] rxConfig Pointer to the function parameters.
+ *
+ * \param [OUT] datarate The datarate index which was set.
+ *
+ * \retval Returns true, if the configuration was applied successfully.
+ */
+bool RegionUS470RxConfig( RxConfigParams_t* rxConfig, int8_t* datarate );
+
+/*!
+ * \brief TX configuration.
+ *
+ * \param [IN] txConfig Pointer to the function parameters.
+ *
+ * \param [OUT] txPower The tx power index which was set.
+ *
+ * \param [OUT] txTimeOnAir The time-on-air of the frame.
+ *
+ * \retval Returns true, if the configuration was applied successfully.
+ */
+bool RegionUS470TxConfig( TxConfigParams_t* txConfig, int8_t* txPower, TimerTime_t* txTimeOnAir );
+
+/*!
+ * \brief The function processes a Link ADR Request.
+ *
+ * \param [IN] linkAdrReq Pointer to the function parameters.
+ *
+ * \retval Returns the status of the operation, according to the LoRaMAC specification.
+ */
+uint8_t RegionUS470LinkAdrReq( LinkAdrReqParams_t* linkAdrReq, int8_t* drOut, int8_t* txPowOut, uint8_t* nbRepOut, uint8_t* nbBytesParsed );
+
+/*!
+ * \brief The function processes a RX Parameter Setup Request.
+ *
+ * \param [IN] rxParamSetupReq Pointer to the function parameters.
+ *
+ * \retval Returns the status of the operation, according to the LoRaMAC specification.
+ */
+uint8_t RegionUS470RxParamSetupReq( RxParamSetupReqParams_t* rxParamSetupReq );
+
+/*!
+ * \brief The function processes a Channel Request.
+ *
+ * \param [IN] newChannelReq Pointer to the function parameters.
+ *
+ * \retval Returns the status of the operation, according to the LoRaMAC specification.
+ */
+int8_t RegionUS470NewChannelReq( NewChannelReqParams_t* newChannelReq );
+
+/*!
+ * \brief The function processes a TX ParamSetup Request.
+ *
+ * \param [IN] txParamSetupReq Pointer to the function parameters.
+ *
+ * \retval Returns the status of the operation, according to the LoRaMAC specification.
+ *         Returns -1, if the functionality is not implemented. In this case, the end node
+ *         shall not process the command.
+ */
+int8_t RegionUS470TxParamSetupReq( TxParamSetupReqParams_t* txParamSetupReq );
+
+/*!
+ * \brief The function processes a DlChannel Request.
+ *
+ * \param [IN] dlChannelReq Pointer to the function parameters.
+ *
+ * \retval Returns the status of the operation, according to the LoRaMAC specification.
+ */
+int8_t RegionUS470DlChannelReq( DlChannelReqParams_t* dlChannelReq );
+
+/*!
+ * \brief Alternates the datarate of the channel for the join request.
+ *
+ * \param [IN] currentDr Current datarate.
+ *
+ * \param [IN] type Alternation type.
+ *
+ * \retval Datarate to apply.
+ */
+int8_t RegionUS470AlternateDr( int8_t currentDr, AlternateDrType_t type );
+
+/*!
+ * \brief Searches and set the next random available channel
+ *
+ * \param [OUT] channel Next channel to use for TX.
+ *
+ * \param [OUT] time Time to wait for the next transmission according to the duty
+ *              cycle.
+ *
+ * \param [OUT] aggregatedTimeOff Updates the aggregated time off.
+ *
+ * \retval Function status [1: OK, 0: Unable to find a channel on the current datarate]
+ */
+LoRaMacStatus_t RegionUS470NextChannel( NextChanParams_t* nextChanParams, uint8_t* channel, TimerTime_t* time, TimerTime_t* aggregatedTimeOff );
+
+/*!
+ * \brief Adds a channel.
+ *
+ * \param [IN] channelAdd Pointer to the function parameters.
+ *
+ * \retval Status of the operation.
+ */
+LoRaMacStatus_t RegionUS470ChannelAdd( ChannelAddParams_t* channelAdd );
+
+/*!
+ * \brief Removes a channel.
+ *
+ * \param [IN] channelRemove Pointer to the function parameters.
+ *
+ * \retval Returns true, if the channel was removed successfully.
+ */
+bool RegionUS470ChannelsRemove( ChannelRemoveParams_t* channelRemove  );
+
+/*!
+ * \brief Computes new datarate according to the given offset
+ *
+ * \param [IN] downlinkDwellTime Downlink dwell time configuration. 0: No limit, 1: 400ms
+ *
+ * \param [IN] dr Current datarate
+ *
+ * \param [IN] drOffset Offset to be applied
+ *
+ * \retval newDr Computed datarate.
+ */
+uint8_t RegionUS470ApplyDrOffset( uint8_t downlinkDwellTime, int8_t dr, int8_t drOffset );
+
+/*!
+ * \brief Sets the radio into beacon reception mode
+ *
+ * \param [IN] rxBeaconSetup Pointer to the function parameters
+ */
+void RegionUS470RxBeaconSetup( RxBeaconSetup_t* rxBeaconSetup, uint8_t* outDr );
+uint16_t  RegionUS470GetBeconChannelByEpoch(uint64_t current_epochtime);
+/*! \} defgroup REGIONUS470 */
+uint32_t RegionUS470GetFrequency(uint16_t channel_index);
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __REGION_US470_H__
\ No newline at end of file
diff --git a/src/mac/region/RegionUS915.c b/src/mac/region/RegionUS915.c
index b6a12da4..1b307790 100644
--- a/src/mac/region/RegionUS915.c
+++ b/src/mac/region/RegionUS915.c
@@ -45,7 +45,15 @@
 static RegionNvmDataGroup1_t* RegionNvmGroup1;
 static RegionNvmDataGroup2_t* RegionNvmGroup2;
 static Band_t* RegionBands;
+void SetTVWSCM()
+{
+    RegionNvmGroup2->ChannelsDefaultMask[0] =0x00FF;
+    RegionNvmGroup2->ChannelsDefaultMask[1] =0x0000;
+    RegionNvmGroup2->ChannelsDefaultMask[2] =0x0000;
+    RegionNvmGroup2->ChannelsDefaultMask[3] =0x0000;
+    RegionNvmGroup2->ChannelsDefaultMask[4] =0x00FF;
 
+}
 static int8_t LimitTxPower( int8_t txPower, int8_t maxBandTxPower, int8_t datarate, uint16_t* channelsMask )
 {
     int8_t txPowerResult = txPower;
@@ -813,7 +821,7 @@ LoRaMacStatus_t RegionUS915NextChannel( NextChanParams_t* nextChanParams, uint8_
     if( RegionCommonCountChannels( RegionNvmGroup1->ChannelsMaskRemaining, 0, 4 ) == 0 )
     { // Reactivate default channels
         RegionCommonChanMaskCopy( RegionNvmGroup1->ChannelsMaskRemaining, RegionNvmGroup2->ChannelsMask, 4  );
-
+F
         RegionNvmGroup1->JoinChannelGroupsCurrentIndex = 0;
     }
     // Check other channels
diff --git a/src/mac/secure-element.h b/src/mac/secure-element.h
index c4446e98..d89da639 100644
--- a/src/mac/secure-element.h
+++ b/src/mac/secure-element.h
@@ -210,6 +210,6 @@ SecureElementStatus_t SecureElementSetPin( uint8_t* pin );
 uint8_t* SecureElementGetPin( void );
 
 /*! \} defgroup SECUREELEMENT */
-
+SecureElementStatus_t SecureElementGetKeyByID( KeyIdentifier_t keyID, Key_t **keyItem);
 #ifdef __cplusplus
 }
 #endif                                                                                                          \
diff --git a/src/peripherals/soft-se/soft-se.c b/src/peripherals/soft-se/soft-se.c
index 671ec308..c0ba60be 100644
--- a/src/peripherals/soft-se/soft-se.c
+++ b/src/peripherals/soft-se/soft-se.c
@@ -52,6 +52,10 @@ static SecureElementNvmData_t* SeNvm;
  */
 static SecureElementStatus_t GetKeyByID( KeyIdentifier_t keyID, Key_t** keyItem )
 {
+    if(keyID==APP_KEY &&  SeNvm->KeyList[0].KeyID !=APP_KEY) //compiler bug
+        {
+              SeNvm->KeyList[0].KeyID=APP_KEY;
+        }
     for( uint8_t i = 0; i < NUM_OF_KEYS; i++ )
     {
         if( SeNvm->KeyList[i].KeyID == keyID )
@@ -118,7 +122,7 @@ static SecureElementStatus_t ComputeCmac( uint8_t* micBxBuffer, uint8_t* buffer,
 
 SecureElementStatus_t SecureElementInit( SecureElementNvmData_t* nvm )
 {
-    SecureElementNvmData_t seNvmInit =
+  static  SecureElementNvmData_t seNvmInit =
     {
         /*!
         * end-device IEEE EUI (big endian)
@@ -446,3 +450,12 @@ uint8_t* SecureElementGetPin( void )
 {
     return SeNvm->Pin;
 }
+ 
+ 
+SecureElementStatus_t SecureElementGetKeyByID( KeyIdentifier_t keyID, Key_t **keyItem)
+{
+    
+    return GetKeyByID(keyID,keyItem);
+}
+ 
+ 
\ No newline at end of file
diff --git a/src/radio/sx126x/radio.c b/src/radio/sx126x/radio.c
index 3a537234..ca13b4d1 100644
--- a/src/radio/sx126x/radio.c
+++ b/src/radio/sx126x/radio.c
@@ -29,7 +29,6 @@
 #include "sx126x.h"
 #include "sx126x-board.h"
 #include "board.h"
-
 /*!
  * \brief Initializes the radio
  *
@@ -767,7 +766,11 @@ void RadioSetTxConfig( RadioModems_t modem, int8_t power, uint32_t fdev,
                         bool fixLen, bool crcOn, bool freqHopOn,
                         uint8_t hopPeriod, bool iqInverted, uint32_t timeout )
 {
-
+ 
+        //   SetTVWSBand(current_rftx_band);
+    
+        
+ 
     switch( modem )
     {
         case MODEM_FSK:
@@ -1245,6 +1248,8 @@ void RadioOnRxTimeoutIrq( void* context )
 void RadioOnDioIrq( void* context )
 {
     IrqFired = true;
+ 
+
 }
 
 void RadioIrqProcess( void )
@@ -1259,7 +1264,7 @@ void RadioIrqProcess( void )
     {
         uint16_t irqRegs = SX126xGetIrqStatus( );
         SX126xClearIrqStatus( irqRegs );
-
+        printf("\t\tIRQ=%02X\r\n",irqRegs);
         // Check if DIO1 pin is High. If it is the case revert IrqFired to true
         CRITICAL_SECTION_BEGIN( );
         if( SX126xGetDio1PinState( ) == 1 )
@@ -1277,12 +1282,16 @@ void RadioIrqProcess( void )
             {
                 RadioEvents->TxDone( );
             }
+      
+         //   SetTVWSBand(ALL_OFF);
+          
+ 
         }
 
         if( ( irqRegs & IRQ_RX_DONE ) == IRQ_RX_DONE )
         {
             TimerStop( &RxTimeoutTimer );
-
+           printf("\t\t------------RECEIVED PKT--------\r\n");
             if( ( irqRegs & IRQ_CRC_ERROR ) == IRQ_CRC_ERROR )
             {
                 if( RxContinuous == false )
diff --git a/src/radio/sx126x/sx126x.c b/src/radio/sx126x/sx126x.c
index 64385536..3e6d4940 100644
--- a/src/radio/sx126x/sx126x.c
+++ b/src/radio/sx126x/sx126x.c
@@ -27,7 +27,7 @@
 #include "delay.h"
 #include "sx126x.h"
 #include "sx126x-board.h"
-
+ 
 /*!
  * \brief Internal frequency of the radio
  */
@@ -163,7 +163,14 @@ uint8_t SX126xGetPayload( uint8_t *buffer, uint8_t *size,  uint8_t maxSize )
 void SX126xSendPayload( uint8_t *payload, uint8_t size, uint32_t timeout )
 {
     SX126xSetPayload( payload, size );
+
     SX126xSetTx( timeout );
+    for(int i=0;i<size;i++)
+     { 
+        printf("%02X",payload[i]);
+     }
+     printf("\r\n");
+
 }
 
 uint8_t SX126xSetSyncWord( uint8_t *syncWord )
@@ -290,6 +297,8 @@ void SX126xSetFs( void )
 void SX126xSetTx( uint32_t timeout )
 {
     uint8_t buf[3];
+ //    printf("TXM\r\n");
+
 
     SX126xSetOperatingMode( MODE_TX );
 
@@ -302,7 +311,9 @@ void SX126xSetTx( uint32_t timeout )
 void SX126xSetRx( uint32_t timeout )
 {
     uint8_t buf[3];
+  //   printf("RXM\r\n");
 
+  
     SX126xSetOperatingMode( MODE_RX );
 
     SX126xWriteRegister( REG_RX_GAIN, 0x94 ); // default gain
@@ -510,6 +521,7 @@ void SX126xSetRfFrequency( uint32_t frequency )
     buf[1] = ( uint8_t )( ( freqInPllSteps >> 16 ) & 0xFF );
     buf[2] = ( uint8_t )( ( freqInPllSteps >> 8 ) & 0xFF );
     buf[3] = ( uint8_t )( freqInPllSteps & 0xFF );
+ //   printf("\tsx126x freq=%d\r\n",frequency);
     SX126xWriteCommand( RADIO_SET_RFFREQUENCY, buf, 4 );
 }
 
diff --git a/src/radio/sx126x/sx126x.h b/src/radio/sx126x/sx126x.h
index a198701c..aeee73ed 100644
--- a/src/radio/sx126x/sx126x.h
+++ b/src/radio/sx126x/sx126x.h
@@ -41,7 +41,7 @@ extern "C"
 /*!
  * Radio complete Wake-up Time with margin for temperature compensation
  */
-#define RADIO_WAKEUP_TIME                           3 // [ms]
+#define RADIO_WAKEUP_TIME                           5// [ms]
 
 /*!
  * \brief Compensation delay for SetAutoTx/Rx functions in 15.625 microseconds
